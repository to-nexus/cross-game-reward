# 핵심 개념 상세 설명

## 1. 포인트 시스템 (Points System)

### 포인트란?

포인트는 **스테이킹 금액과 기간을 공정하게 반영**하기 위한 측정 단위입니다.

### 포인트 계산 공식

```
포인트 = (스테이킹 금액 × 경과 시간 × POINTS_PRECISION) / 시간 단위

여기서:
- 스테이킹 금액: 스테이킹한 토큰 수량
- 경과 시간: (종료 블록 - 시작 블록) × 블록 시간 (초)
- POINTS_PRECISION: 1e6 (정밀도)
- 시간 단위: 기본 3600초 (1시간)
```

### 예시 계산

**시나리오:**
- Alice가 100 CROSS를 스테이킹
- 720 블록 경과 (1초/블록 기준 = 720초)
- 시간 단위: 3600초 (1시간)

**계산:**
```
포인트 = (100 × 720 × 1e6) / 3600
      = 72,000 × 1e6 / 3600
      = 20,000,000
      = 20 포인트 (1e6 단위)
```

**해석:**
- 100 CROSS를 0.2시간(12분) 동안 스테이킹
- 100 CROSS × 0.2시간 = 20 포인트

### 정밀도 (Precision)

**왜 1e6을 곱하나?**
- Solidity는 소수점을 지원하지 않음
- 1e6 = 1,000,000을 곱하여 소수점 6자리까지 표현
- 예: 0.123456 포인트 = 123,456 (내부 표현)

**정밀도 효과:**
```
짧은 시간도 정확히 측정:
- 1초 스테이킹: (1 × 1 × 1e6) / 3600 = 277 (≈ 0.000277 포인트)
- 소액도 정확히 반영 가능
```

### 시간 단위 조정

**기본값: 1시간 (3600초)**
- 1 CROSS를 1시간 스테이킹 = 1 포인트

**조정 가능:**
```solidity
setPointsTimeUnit(1 days)  // 1 CROSS × 1일 = 1 포인트
setPointsTimeUnit(1 weeks) // 1 CROSS × 1주 = 1 포인트
```

### 포인트 누적 방식

**증분 업데이트:**
```
블록 100: Alice 스테이킹 100 CROSS
    포인트 = 0
    lastUpdateBlock = 100

블록 200: 포인트 업데이트
    추가 포인트 = (100 × (200-100) × blockTime) / timeUnit
    총 포인트 = 0 + 추가 포인트
    lastUpdateBlock = 200

블록 250: Alice 추가 스테이킹 50 CROSS
    추가 포인트 = (100 × (250-200) × blockTime) / timeUnit
    총 포인트 += 추가 포인트
    잔액 = 100 + 50 = 150 CROSS
    lastUpdateBlock = 250

블록 300: 포인트 업데이트
    추가 포인트 = (150 × (300-250) × blockTime) / timeUnit
    총 포인트 += 추가 포인트
```

### 포인트의 용도

1. **보상 분배 비율 결정**
```
유저 보상 = 총 보상 × (유저 포인트 / 총 포인트)
```

2. **기여도 측정**
```
기여도 = 유저 포인트 / 총 포인트 × 100%
```

3. **공정성 보장**
```
- 늦게 참여한 사람도 참여 기간에 비례하여 보상
- 많이 스테이킹한 사람이 더 많은 보상
- 시간 × 금액을 모두 고려
```

## 2. 시즌 시스템 (Season System)

### 시즌이란?

시즌은 **보상 분배의 기본 주기**입니다. 각 시즌마다 독립적으로 보상이 분배됩니다.

### 시즌 구조

```solidity
struct Season {
    uint seasonNumber;        // 시즌 번호 (1부터 시작)
    uint startBlock;          // 시작 블록
    uint endBlock;            // 종료 블록
    bool isFinalized;         // 종료 여부
    uint totalPoints;         // 총 포인트 (finalize 시 확정, 불변 캐시)
    uint seasonTotalStaked;   // 시즌 중 총 스테이킹 (집계용, 변동)
    uint lastAggregatedBlock; // 마지막 집계 블록
    uint aggregatedPoints;    // 집계된 포인트 (실시간 누적, finalize 시 totalPoints로 복사)
}
```

**totalPoints vs aggregatedPoints:**
- `aggregatedPoints`: 시즌 진행 중 계속 증가하는 **실시간 누적값**
- `totalPoints`: 시즌 종료 후 **확정된 캐시값** (한 번 설정 후 불변)
- **분리 이유**: 
  - `totalPoints == 0`으로 아직 최종 계산이 안 된 시즌 식별 (lazy)
  - 가스 효율: finalize 후 totalPoints를 읽는 것이 재계산보다 저렴
  - 명확성: 진행 중 vs 확정 상태 구분
  - 안전성: finalize 후 값 변경 방지

### 시즌 생명주기

```
[대기] → [활성] → [종료] → [Finalized]

대기 (Before Start):
- currentSeason = 0 또는 이전 시즌 finalized
- block.number < nextSeasonStartBlock

활성 (Active):
- isFinalized = false
- startBlock ≤ block.number ≤ endBlock
- 스테이킹/출금 가능
- 포인트 누적 중

종료 (Ended):
- block.number > endBlock
- 아직 finalized = false
- 다음 트랜잭션에서 자동 롤오버

Finalized:
- isFinalized = true
- totalPoints 확정
- 보상 청구 가능
- 더 이상 변경 불가
```

### 시즌 전환 메커니즘

**자동 롤오버:**
```solidity
function _ensureSeason() internal {
    // 시즌 0일 때
    if (currentSeason == 0) {
        if (block.number >= nextSeasonStartBlock) {
            _startFirstSeason();
        }
        return;
    }
    
    // 여러 시즌이 지나간 경우 모두 롤오버 (최대 50개)
    uint maxRollovers = 50;
    uint rolloversPerformed = 0;
    
    while (currentSeason > 0 && rolloversPerformed < maxRollovers) {
        Season storage current = seasons[currentSeason];
        if (block.number <= current.endBlock) break;
        
        _rolloverSeason();
        rolloversPerformed++;
    }
}
```

**언제 호출되나?**
- `stake()` 호출 시
- `withdrawAll()` 호출 시
- 모든 상태 변경 트랜잭션 시

**다중 시즌 처리:**
- 오랜 기간 활동이 없어도 자동으로 모든 시즌 롤오버
- 한 번에 최대 50개 시즌까지 처리 (가스 한도 고려)
- 실제로는 대부분 1-2개 시즌만 롤오버됨

**첫 번째 시즌 시작:**
```
nextSeasonStartBlock 도달
    ↓
첫 트랜잭션 발생
    ↓
_startFirstSeason() 호출
    ↓
currentSeason = 1
seasons[1] 생성
    ↓
시즌 1 활성화
```

**시즌 롤오버:**
```
시즌 N 종료 블록 도달
    ↓
첫 트랜잭션 발생
    ↓
_rolloverSeason() 호출
    ↓
_finalizeSeasonAggregation(N)
    ↓
시즌 N finalized = true
    ↓
currentSeason = N+1
seasons[N+1] 생성
    ↓
시즌 N+1 시작
```

### 시즌 블록 계산

**기본 시즌 길이:**
```
defaultSeasonBlocks = 2,592,000 블록

1초/블록 기준:
2,592,000초 = 43,200분 = 720시간 = 30일
```

**시즌 종료 블록:**
```
endBlock = startBlock + seasonBlocks

예시:
startBlock = 1,000,000
seasonBlocks = 2,592,000
endBlock = 3,592,000
```

**풀 종료 블록 처리:**
```solidity
if (poolEndBlock > 0 && endBlock > poolEndBlock) {
    endBlock = poolEndBlock;
}
```

### 시즌별 사용자 데이터

```solidity
struct UserSeasonData {
    uint points;        // 해당 시즌의 포인트
    uint balance;       // 해당 시즌의 잔액
    uint joinBlock;     // 시즌 참여 블록
    bool claimed;       // 보상 청구 여부
    bool finalized;     // 스냅샷 완료 여부
}
```

**예시:**
```
시즌 1 (블록 1000-2000):
- Alice 블록 1000에 100 CROSS 스테이킹
- Alice의 UserSeasonData[1]:
  - points: 계산된 포인트
  - balance: 100
  - joinBlock: 1000
  - claimed: false
  - finalized: true (시즌 종료 후)

시즌 2 (블록 2001-3000):
- Alice 계속 스테이킹 유지
- Alice의 UserSeasonData[2]:
  - points: 시즌 2의 포인트
  - balance: 100
  - joinBlock: 2001
  - claimed: false
  - finalized: false (시즌 진행 중)
```

## 3. 시즌 집계 시스템 (Season Aggregation)

### 문제: 총 포인트 계산의 복잡도

**단순한 방법 (O(N)):**
```
총 포인트 = Σ(각 스테이커의 포인트)

문제:
- 스테이커가 1000명이면 1000번 계산 필요
- 가스 비용 매우 높음
- 실용적이지 않음
```

**최적화된 방법 (O(1)):**
```
총 포인트 = Σ(총 스테이킹 × 시간 구간)

장점:
- 스테이커 수와 무관하게 O(1)
- 증분 업데이트로 효율적
- 가스 비용 절감
```

### 집계 원리

**수학적 근거:**
```
모든 유저의 포인트 합:
Σ(각 유저 잔액 × 시간) = (모든 유저 잔액의 합) × 시간
                        = 총 스테이킹 × 시간
```

**예시:**
```
블록 100:
- Alice: 50 CROSS
- Bob: 30 CROSS
- 총 스테이킹: 80 CROSS

블록 200 (100블록 경과):
개별 계산:
- Alice 포인트: 50 × 100 = 5,000
- Bob 포인트: 30 × 100 = 3,000
- 총 포인트: 8,000

집계 계산:
- 총 포인트: 80 × 100 = 8,000 ✓ 동일!
```

### 집계 업데이트 시점

**1. 스테이킹 시:**
```solidity
_updateSeasonAggregation(currentSeason);  // 현재까지 집계
currentSeasonData.seasonTotalStaked += amount;  // 총량 증가
```

**2. 출금 시:**
```solidity
_updateSeasonAggregation(currentSeason);  // 현재까지 집계
currentSeasonData.seasonTotalStaked -= amount;  // 총량 감소
```

**3. 시즌 종료 시:**
```solidity
_finalizeSeasonAggregation(seasonNum);  // 최종 집계
```

### 집계 계산 로직

```solidity
function _updateSeasonAggregation(uint seasonNum) internal {
    Season storage season = seasons[seasonNum];
    
    // 이미 최신이면 skip
    if (season.lastAggregatedBlock >= block.number) return;
    
    // 총 스테이킹이 0이면 시간만 업데이트
    if (season.seasonTotalStaked == 0) {
        season.lastAggregatedBlock = block.number;
        return;
    }
    
    // 증분 포인트 계산
    uint additionalPoints = PointsLib.calculatePoints(
        season.seasonTotalStaked,
        season.lastAggregatedBlock,
        block.number,
        blockTime,
        pointsTimeUnit
    );
    
    // 집계 포인트에 추가
    season.aggregatedPoints += additionalPoints;
    season.lastAggregatedBlock = block.number;
}
```

### 집계 예시 시뮬레이션

```
시나리오:
- 시즌 시작: 블록 1000
- 시간 단위: 100블록 = 1포인트 (간단화)

블록 1000 (시즌 시작):
- 총 스테이킹: 0
- aggregatedPoints: 0
- lastAggregatedBlock: 1000

블록 1050 (Alice 100 스테이킹):
- 집계 업데이트: 0 × (1050-1000) = 0
- 총 스테이킹: 0 → 100
- aggregatedPoints: 0
- lastAggregatedBlock: 1050

블록 1100 (Bob 50 스테이킹):
- 집계 업데이트: 100 × (1100-1050) / 100 = 50 포인트
- 총 스테이킹: 100 → 150
- aggregatedPoints: 0 + 50 = 50
- lastAggregatedBlock: 1100

블록 1200 (시즌 종료):
- 집계 업데이트: 150 × (1200-1100) / 100 = 150 포인트
- aggregatedPoints: 50 + 150 = 200
- totalPoints = 200 (확정)

검증:
- Alice: 100 × (1200-1050) / 100 = 150 포인트
- Bob: 50 × (1200-1100) / 100 = 50 포인트
- 합계: 150 + 50 = 200 ✓
```

## 4. 지연 스냅샷 시스템 (Lazy Snapshot)

### 문제: 시즌 전환 시 가스 비용

**즉시 처리 방식:**
```
시즌 종료 시:
for (모든 스테이커) {
    사용자 시즌 데이터 계산
    저장
}

문제:
- 스테이커 1000명 → 매우 높은 가스
- 한 트랜잭션에 불가능
- 현실적으로 구현 불가
```

**지연 처리 방식:**
```
시즌 종료 시:
- 아무것도 하지 않음 (O(1))

보상 청구 시:
- 해당 유저의 데이터만 계산
- 필요한 시즌만 처리
- 개별 유저가 가스 부담
```

### 지연 스냅샷 원리

**핵심 아이디어:**
```
과거 시즌 데이터를 "소급 계산" 가능:
- 시즌은 이미 종료됨 (불변)
- 유저의 스테이킹 기록은 저장되어 있음
- 필요할 때 계산하면 됨
```

**필요 시점:**
1. 보상 청구 시
2. 새로운 스테이킹 시
3. 출금 시

### 구현 로직

```solidity
function _ensureUserAllPreviousSeasons(address user) internal {
    if (currentSeason == 0) return;
    
    // 마지막으로 처리한 시즌
    uint startSeason = lastFinalizedSeason[user];
    if (startSeason == 0) startSeason = 1;
    
    // 현재 시즌까지 (현재 시즌은 제외)
    if (startSeason >= currentSeason) return;
    
    // 이전 시즌들을 순회하며 스냅샷
    for (uint i = startSeason; i < currentSeason;) {
        _ensureUserSeasonSnapshot(user, i);
        unchecked { ++i; }
    }
    
    // 처리 완료 기록
    lastFinalizedSeason[user] = currentSeason - 1;
}
```

**개별 시즌 스냅샷:**
```solidity
function _ensureUserSeasonSnapshot(address user, uint seasonNum) internal {
    Season storage season = seasons[seasonNum];
    
    // 시즌이 종료되지 않았으면 skip
    if (!season.isFinalized) return;
    
    UserSeasonData storage userData = userSeasonData[seasonNum][user];
    
    // 이미 처리됐으면 skip
    if (userData.finalized) return;
    
    // 현재 포지션 정보
    StakePosition storage position = userStakes[user];
    
    // 스테이킹이 없었으면 skip
    if (position.balance == 0 && userData.balance == 0) {
        userData.finalized = true;
        return;
    }
    
    // 포인트 계산
    uint balanceToUse = userData.balance > 0 ? userData.balance : position.balance;
    uint joinBlockToUse = userData.joinBlock > 0 ? userData.joinBlock : position.lastUpdateBlock;
    
    // 시즌 범위 내에서 포인트 계산
    if (joinBlockToUse < season.startBlock) {
        userData.balance = balanceToUse;
        userData.joinBlock = season.startBlock;
        userData.points = PointsLib.calculatePoints(
            balanceToUse,
            season.startBlock,
            season.endBlock,
            blockTime,
            pointsTimeUnit
        );
    } else if (joinBlockToUse <= season.endBlock) {
        userData.balance = balanceToUse;
        userData.joinBlock = joinBlockToUse;
        userData.points = PointsLib.calculatePoints(
            balanceToUse,
            joinBlockToUse,
            season.endBlock,
            blockTime,
            pointsTimeUnit
        );
    }
    
    userData.finalized = true;
}
```

### 예시 시나리오

```
블록 1000: 시즌 1 시작
블록 1050: Alice 100 CROSS 스테이킹
블록 2000: 시즌 1 종료, 시즌 2 시작
    → Alice의 시즌 1 데이터는 아직 계산 안 함
    → lastFinalizedSeason[Alice] = 0

블록 2500: Alice 추가 스테이킹
    → _ensureUserAllPreviousSeasons(Alice) 호출
    → 시즌 1 스냅샷:
        - balance: 100
        - joinBlock: 1050
        - points: 100 × (2000-1050) × blockTime / timeUnit
        - finalized: true
    → lastFinalizedSeason[Alice] = 1

블록 3000: 시즌 2 종료, 시즌 3 시작
    → Alice의 시즌 2 데이터는 아직 계산 안 함

블록 3500: Alice 시즌 1 보상 청구
    → 시즌 1은 이미 finalized
    → 시즌 2 스냅샷:
        - balance: 150 (추가 스테이킹 포함)
        - joinBlock: 2001
        - points: 150 × (3000-2001) × blockTime / timeUnit
        - finalized: true
    → lastFinalizedSeason[Alice] = 2
    → 시즌 1 보상 지급
```

### 배치 처리 최적화

```solidity
function finalizeUserSeasonsBatch(address user, uint maxSeasons) 
    external 
    returns (uint processed) 
{
    // 한 번에 여러 시즌 처리
    // 가스 한도 내에서 최대한 처리
    
    for (uint i = startSeason; i <= endSeason && processed < maxSeasons;) {
        _ensureUserSeasonSnapshot(user, i);
        unchecked {
            ++i;
            ++processed;
        }
    }
    
    // 한 번만 스토리지 업데이트 (가스 절약)
    if (processed > 0) {
        lastFinalizedSeason[user] = lastProcessed;
    }
}
```

## 5. 보상 분배 시스템

### 비례 분배 원칙

**공식:**
```
유저 보상 = 총 보상 × (유저 포인트 / 총 포인트)
```

**예시:**
```
시즌 1 종료:
- 총 포인트: 1000
- 총 보상: 100 토큰

Alice (포인트 400):
- 보상 = 100 × (400 / 1000) = 40 토큰

Bob (포인트 300):
- 보상 = 100 × (300 / 1000) = 30 토큰

Charlie (포인트 300):
- 보상 = 100 × (300 / 1000) = 30 토큰

합계: 40 + 30 + 30 = 100 ✓
```

### 보상 예치

```solidity
function fundSeason(uint season, address token, uint amount) external {
    // 토큰 전송
    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    
    // 보상 누적 (여러 번 예치 가능)
    seasonRewards[season][token] += amount;
    
    emit SeasonFunded(season, token, amount, msg.sender);
}
```

**특징:**
- 여러 번 예치 가능
- 여러 토큰 지원
- 미래 시즌에도 미리 예치 가능

### 보상 청구

```solidity
function claimSeason(uint seasonNumber, address rewardToken) external {
    Season storage season = seasons[seasonNumber];
    
    // 시즌이 종료되어야 청구 가능
    require(season.isFinalized, "Season not ended");
    
    // 유저 시즌 데이터 확보 (지연 스냅샷)
    _ensureUserSeasonSnapshot(msg.sender, seasonNumber);
    
    UserSeasonData storage userData = userSeasonData[seasonNumber][msg.sender];
    
    // 중복 청구 방지
    require(!userData.claimed, "Already claimed");
    
    uint userPoints = userData.points;
    uint totalPoints = season.totalPoints;
    
    // 보상 지급
    if (userPoints > 0 && totalPoints > 0) {
        userData.claimed = true;
        rewardPool.payUser(
            msg.sender,
            seasonNumber,
            rewardToken,
            userPoints,
            totalPoints
        );
    }
}
```

### 중복 청구 방지

**3단계 방어:**

1. **UserSeasonData.claimed 플래그**
```solidity
require(!userData.claimed, "Already claimed");
userData.claimed = true;
```

2. **RewardPool.hasClaimedSeasonReward 매핑**
```solidity
require(!hasClaimedSeasonReward[user][season][token], "Already claimed");
hasClaimedSeasonReward[user][season][token] = true;
```

3. **재진입 방지**
```solidity
function claimSeason(...) external nonReentrant { ... }
```

### 다중 토큰 보상

**동일 시즌, 다른 토큰:**
```
시즌 1:
- Token A: 100개 예치
- Token B: 200개 예치

Alice (포인트 40%):
- Token A 청구: 40개
- Token B 청구: 80개

각 토큰별로 독립적으로 청구
```

### 보상 계산 최적화

```solidity
function getExpectedReward(address user, uint season, address token)
    external view returns (uint)
{
    // 이미 청구했으면 0
    if (hasClaimedSeasonReward[user][season][token]) return 0;
    
    // 포인트 조회 (view 함수, 상태 변경 없음)
    uint userPoints = stakingPool.getSeasonUserPoints(season, user);
    uint totalPoints = stakingPool.seasonTotalPointsSnapshot(season);
    
    if (userPoints == 0 || totalPoints == 0) return 0;
    
    // 비례 계산
    uint totalReward = seasonRewards[season][token];
    return (totalReward × userPoints) / totalPoints;
}
```

## 6. Native CROSS와 WCROSS

### WCROSS란?

**Wrapped CROSS:**
- Native CROSS를 ERC20 표준으로 래핑
- 스마트 컨트랙트에서 사용 가능
- 1:1 교환 비율

### 변환 메커니즘

**Deposit (Native → WCROSS):**
```solidity
function deposit() external payable {
    balanceOf[msg.sender] += msg.value;
    totalSupply += msg.value;
    emit Deposit(msg.sender, msg.value);
}

// 또는 receive 함수로 자동 deposit
receive() external payable {
    balanceOf[msg.sender] += msg.value;
    totalSupply += msg.value;
    emit Deposit(msg.sender, msg.value);
}
```

**Withdraw (WCROSS → Native):**
```solidity
function withdraw(uint amount) external {
    require(balanceOf[msg.sender] >= amount, "Insufficient balance");
    
    balanceOf[msg.sender] -= amount;
    totalSupply -= amount;
    
    (bool success,) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
    
    emit Withdrawal(msg.sender, amount);
}
```

### StakingRouter의 역할

**사용자 경험 개선:**
```
일반 사용자:
Native CROSS → StakingRouter → 자동 wrap → 스테이킹

컨트랙트 사용자:
WCROSS approve → StakingPool.stake() → 직접 스테이킹
```

**자동 변환 플로우:**

**스테이킹:**
```solidity
function stake(uint projectID) external payable {
    // 1. Native CROSS를 WCROSS로 변환
    wcross.deposit{value: msg.value}();
    
    // 2. WCROSS를 StakingPool에 approve
    IERC20(wcross).safeIncreaseAllowance(stakingPool, msg.value);
    
    // 3. 사용자를 위해 스테이킹
    IStakingPool(stakingPool).stakeFor(msg.sender, msg.value);
}
```

**출금:**
```solidity
function unstake(uint projectID) external {
    // 1. StakingPool에서 출금 (Router가 WCROSS 받음)
    IStakingPool(stakingPool).withdrawAllFor(msg.sender);
    
    // 2. Router가 받은 WCROSS 확인
    uint wcrossBalance = IERC20(wcross).balanceOf(address(this));
    
    // 3. WCROSS를 Native CROSS로 변환
    wcross.withdraw(wcrossBalance);
    
    // 4. Native CROSS를 사용자에게 전송
    (bool success,) = msg.sender.call{value: wcrossBalance}("");
    require(success, "Transfer failed");
}
```

### Transfer 이벤트 처리

**중복 방지:**
```solidity
// deposit/withdraw 시에는 Transfer 이벤트 발생 안 함
// 일반 전송 시에만 발생
function transfer(address to, uint amount) external returns (bool) {
    // ... 전송 로직 ...
    emit Transfer(msg.sender, to, amount);  // 여기서만 발생
    return true;
}
```

**이유:**
- Explorer에서 중복 거래 표시 방지
- Deposit 이벤트와 Transfer 이벤트가 분리됨
- 더 명확한 이벤트 추적

## 다음 문서

- [03-컨트랙트상세.md](./03-컨트랙트상세.md): 함수별 상세 설명
- [04-워크플로우.md](./04-워크플로우.md): 사용 시나리오

