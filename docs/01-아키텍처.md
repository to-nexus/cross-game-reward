# 시스템 아키텍처

## 전체 아키텍처 개요

Cross Staking 시스템은 계층적이고 모듈화된 아키텍처로 설계되었습니다.

```
┌─────────────────────────────────────────────────────────────┐
│                         사용자 레이어                          │
│  (Native CROSS를 사용하는 일반 사용자, 프론트엔드 애플리케이션)   │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      라우터 레이어                             │
│                    StakingRouter                             │
│  • Native CROSS 처리                                         │
│  • 사용자 편의 함수                                           │
│  • 배치 조회                                                 │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      프로토콜 레이어                           │
│                   StakingProtocol                            │
│  • 프로젝트 팩토리                                            │
│  • 중앙 관리                                                 │
│  • 설정 관리                                                 │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌──────────────────────────┬──────────────────────────────────┐
│    프로젝트 A            │       프로젝트 B                  │
├──────────┬───────────────┼──────────┬───────────────────────┤
│ Staking  │  Reward       │ Staking  │  Reward               │
│  Pool    │   Pool        │  Pool    │   Pool                │
└──────────┴───────────────┴──────────┴───────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      토큰 레이어                              │
│                        WCROSS                                │
│  • Native CROSS ↔ ERC20 변환                                │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      확장 레이어 (선택적)                      │
│                    Staking Addons                            │
│  • RankingAddon (랭킹 집계)                                  │
│  • 커스텀 Addon (배지, 통계 등)                              │
└─────────────────────────────────────────────────────────────┘
```

## 컨트랙트 계층 구조

### 1. 인터페이스 계층 (interfaces/)

모든 핵심 컨트랙트는 인터페이스를 통해 정의되어 있습니다.

```
IStakingProtocol         프로토콜 팩토리 인터페이스
    ↓
IStakingPool             스테이킹 풀 인터페이스
    ↓
IRewardPool              보상 풀 인터페이스
    ↓
IStakingAddon            확장 애드온 인터페이스
```

**인터페이스 역할:**
- 컨트랙트 간 의존성 명확화
- 업그레이드 가능성 확보
- 테스트 및 모킹 용이성

### 2. 라이브러리 계층 (libraries/)

순수 로직을 라이브러리로 분리하여 재사용성과 가스 효율성을 확보합니다.

#### PointsLib
```solidity
// 포인트 계산 관련 순수 함수들
- calculatePoints()           // 기본 포인트 계산
- calculateAggregatedPoints() // 집계 포인트 계산
- calculateProRata()          // 비례 분배 계산
```

**특징:**
- `internal pure` 함수로 구성
- 인라인 최적화 가능
- 정밀도 상수 제공 (1e6)

#### SeasonLib
```solidity
// 시즌 관련 검증 및 헬퍼 함수들
- isSeasonActive()        // 시즌 활성 여부
- isSeasonEnded()         // 시즌 종료 여부
- validateSeasonBlocks()  // 시즌 블록 검증
- isBlockInSeason()       // 블록이 시즌 범위 내인지
- calculateEffectiveStart() // 유효 시작 블록 계산
```

**특징:**
- 시즌 관련 비즈니스 로직 캡슐화
- 일관된 시즌 상태 관리

### 3. 베이스 컨트랙트 계층 (base/)

공통 로직을 추상 컨트랙트로 추출하여 코드 재사용성을 극대화합니다.

#### CrossStakingBase

```solidity
abstract contract CrossStakingBase is 
    AccessControlDefaultAdminRules,
    ReentrancyGuardTransient
```

**제공 기능:**
- 공통 에러 정의
- 입력 검증 함수
- 접근 제어 기반 설정
- 재진입 방지 기반 제공

**상속 관계:**
```
CrossStakingBase
    ├─ StakingPoolBase
    └─ RewardPoolBase
```

#### StakingPoolBase

```solidity
abstract contract StakingPoolBase is 
    IStakingPool,
    CrossStakingBase
```

**핵심 구조:**

1. **상태 변수**
```solidity
struct StakePosition {
    uint balance;           // 스테이킹 잔액
    uint points;            // 누적 포인트
    uint lastUpdateBlock;   // 마지막 업데이트 블록
}

struct Season {
    uint seasonNumber;      // 시즌 번호
    uint startBlock;        // 시작 블록
    uint endBlock;          // 종료 블록
    bool isFinalized;       // 종료 여부
    uint totalPoints;       // 총 포인트 (캐시)
    uint seasonTotalStaked; // 시즌 중 총 스테이킹 (집계용)
    uint lastAggregatedBlock; // 마지막 집계 블록
    uint aggregatedPoints;  // 집계된 포인트
}

struct UserSeasonData {
    uint points;           // 유저 시즌 포인트
    uint balance;          // 유저 시즌 잔액
    uint joinBlock;        // 참여 블록
    bool claimed;          // 청구 여부
    bool finalized;        // 스냅샷 완료 여부
}
```

2. **핵심 함수 플로우**

**스테이킹 플로우:**
```
stake() / stakeFor()
    ↓
_stakeFor()
    ↓
_beforeStake() [Hook]
    ↓
포인트 계산 및 업데이트
    ↓
토큰 전송 (SafeERC20)
    ↓
집계 업데이트
    ↓
_afterStake() [Hook]
    ↓
Addon 알림 (안전 호출)
```

**출금 플로우:**
```
withdrawAll() / withdrawAllFor()
    ↓
_withdrawAll()
    ↓
_beforeWithdraw() [Hook]
    ↓
집계 업데이트
    ↓
토큰 전송 (SafeERC20)
    ↓
_afterWithdraw() [Hook]
    ↓
Addon 알림 (안전 호출)
```

**시즌 전환 플로우:**
```
_ensureSeason()
    ↓
현재 블록 확인
    ↓
시즌 0인가? → _startFirstSeason()
    ↓
시즌 종료됨? → _rolloverSeason()
    ↓
_finalizeSeasonAggregation()
    ↓
Addon 알림 (시즌 종료)
    ↓
새 시즌 생성
```

3. **집계 시스템 (Aggregation System)**

**목적:** O(1) 복잡도로 시즌 총 포인트 계산

**메커니즘:**
```
집계 포인트 = Σ(총 스테이킹 × 시간 구간)

시간 t1: 총 스테이킹 100, 집계 0
  ↓ 10블록 경과
시간 t2: 집계 += 100 × 10 = 1000
  ↓ 스테이킹 +50 (총 150)
  ↓ 20블록 경과
시간 t3: 집계 += 150 × 20 = 4000
  총 집계 = 1000 + 4000 = 5000
```

**함수:**
- `_updateSeasonAggregation()`: 증분 업데이트
- `_finalizeSeasonAggregation()`: 시즌 종료 시 최종 집계

4. **지연 스냅샷 시스템 (Lazy Snapshot)**

**목적:** 가스 효율적인 사용자 시즌 데이터 관리

**메커니즘:**
```
스테이킹 시 → 현재 시즌만 기록
시즌 전환 시 → 자동 전환만, 유저 데이터 미처리
청구/스테이킹 시 → _ensureUserAllPreviousSeasons()
                  → 이전 시즌들을 소급 계산
                  → UserSeasonData에 저장
                  → finalized = true 설정
```

**함수:**
- `_ensureUserAllPreviousSeasons()`: 모든 이전 시즌 처리
- `_ensureUserSeasonSnapshot()`: 특정 시즌 스냅샷

#### RewardPoolBase

```solidity
abstract contract RewardPoolBase is 
    IRewardPool,
    CrossStakingBase
```

**핵심 구조:**

1. **상태 변수**
```solidity
mapping(uint => mapping(address => uint)) seasonRewards;
// 시즌별 토큰별 총 보상

mapping(uint => mapping(address => uint)) seasonClaimed;
// 시즌별 토큰별 청구된 보상

mapping(address => mapping(uint => mapping(address => bool))) 
    hasClaimedSeasonReward;
// 유저별 시즌별 토큰별 청구 여부
```

2. **보상 분배 플로우**

```
payUser()
    ↓
청구 여부 확인 (중복 청구 방지)
    ↓
포인트 검증
    ↓
기본 보상 계산 (비례 분배)
    ↓
_calculateBonusReward() [Hook]
    ↓
잔액 확인
    ↓
_beforePayUser() [Hook]
    ↓
토큰 전송 (SafeERC20)
    ↓
_afterPayUser() [Hook]
```

3. **Hook 시스템**

```solidity
// 확장 포인트
function _beforeFundSeason(uint season, address token, uint amount)
function _afterFundSeason(uint season, address token, uint amount)
function _calculateBonusReward(...) returns (uint bonusAmount)
function _beforePayUser(address user, uint season, address token, uint amount)
function _afterPayUser(address user, uint season, address token, uint amount)
```

### 4. 구현 컨트랙트 계층

#### StakingProtocol

**역할:** 프로젝트 팩토리 및 중앙 관리

**구조:**
```solidity
struct ProjectInfo {
    address stakingPool;
    address rewardPool;
    string name;
    bool isActive;
    uint createdAt;
    address creator;
}

mapping(uint => ProjectInfo) projects;
mapping(string => uint) projectIDByName;
mapping(address => uint[]) projectsByAddress;
```

**Code 컨트랙트 패턴:**
```
StakingProtocol
    ↓
stakingPoolCodeContract.code()  // creation code 조회
    ↓
create(code + constructorArgs)  // 어셈블리로 배포
    ↓
StakingPool 인스턴스 생성
```

**장점:**
- 코드 사이즈 제한 회피
- 배포 비용 최적화
- 업그레이드 용이성

#### StakingPool

**상속 관계:**
```
StakingPool extends StakingPoolBase
```

**추가 기능:**
- RewardPool 연결 관리
- Router 승인 관리
- 포인트 조회 최적화
- 배치 처리 함수

**주요 View 함수:**
```solidity
getStakePosition(user)           // 현재 포지션
getCurrentSeasonInfo()           // 현재 시즌 정보
getSeasonUserPoints(season, user) // 시즌별 유저 포인트
seasonTotalPointsSnapshot(season) // 시즌 총 포인트
getExpectedSeasonPoints(season, user) // 예상 포인트
getExpectedSeasonReward(season, user, token) // 예상 보상
previewClaim(season, user, token) // 청구 미리보기
getUserSeasonData(season, user)   // 시즌 데이터 상세
```

#### RewardPool

**상속 관계:**
```
RewardPool extends RewardPoolBase
```

**추가 기능:**
- StakingPool 연동
- 보상 예치 (fundSeason)
- 보상 청구 (payUser)
- 토큰 회수 (sweep)

**보상 계산 로직:**
```solidity
function getExpectedReward(address user, uint season, address token)
{
    userPoints = stakingPool.getSeasonUserPoints(season, user);
    totalPoints = stakingPool.seasonTotalPointsSnapshot(season);
    totalReward = seasonRewards[season][token];
    
    return (totalReward × userPoints) / totalPoints;
}
```

#### StakingRouter

**역할:** 사용자 친화적 인터페이스 제공

**핵심 기능:**

1. **Native CROSS 스테이킹**
```solidity
function stake(uint projectID) payable
    ↓
wcross.deposit{value: msg.value}()
    ↓
IERC20(wcross).approve(stakingPool, amount)
    ↓
stakingPool.stakeFor(msg.sender, amount)
```

2. **Native CROSS 출금**
```solidity
function unstake(uint projectID)
    ↓
stakingPool.withdrawAllFor(msg.sender)
    ↓
wcross.withdraw(balance)
    ↓
msg.sender.call{value: balance}("")
```

3. **배치 조회**
```solidity
getUserStakingSummary()      // 여러 프로젝트 스테이킹 요약
getExpectedRewardsBatch()    // 여러 시즌 보상 일괄 조회
getActiveProjects()          // 활성 프로젝트 목록
getSeasonHistory()           // 시즌 히스토리
```

#### WCROSS

**역할:** Native CROSS ↔ ERC20 변환

**특징:**
- 표준 WETH 구현 기반
- deposit/withdraw 시 Transfer 이벤트 생략 (explorer 중복 방지)
- receive/fallback으로 자동 deposit 지원

```solidity
deposit()    // Native → WCROSS
withdraw()   // WCROSS → Native
transfer()   // 일반 ERC20 전송
```

## 데이터 흐름

### 스테이킹 데이터 흐름

```
[사용자]
    ↓ Native CROSS
[StakingRouter]
    ↓ WCROSS (wrapped)
[StakingPool]
    ↓ 잔액 기록
[UserStake mapping]
    ↓ 포인트 계산
[UserSeasonData mapping]
    ↓ 집계 업데이트
[Season.aggregatedPoints]
```

### 보상 데이터 흐름

```
[프로젝트 생성자]
    ↓ 보상 토큰
[RewardPool]
    ↓ 예치 기록
[seasonRewards mapping]
    ↓ 시즌 종료
[StakingPool 시즌 finalize]
    ↓ 청구
[RewardPool.payUser()]
    ↓ 보상 전송
[사용자]
```

### 시즌 전환 데이터 흐름

```
[블록 진행]
    ↓ 시즌 종료 블록 도달
[첫 트랜잭션]
    ↓ _ensureSeason()
[_rolloverSeason()]
    ↓ 이전 시즌 집계 완료
[_finalizeSeasonAggregation()]
    ↓ Addon 알림
[_notifySeasonEnd()]
    ↓ 새 시즌 생성
[seasons[newSeasonNumber]]
```

## 권한 아키텍처

### 역할 계층 구조

```
DEFAULT_ADMIN_ROLE (최고 관리자)
    ├─ MANAGER_ROLE (프로토콜 관리자)
    ├─ REWARD_POOL_ROLE (RewardPool 전용)
    └─ ROUTER_ROLE (Router 전용)
```

### 권한 매핑

| 역할 | 권한 | 사용처 |
|-----|------|-------|
| DEFAULT_ADMIN_ROLE | 모든 관리 기능 | StakingProtocol, StakingPool, RewardPool |
| MANAGER_ROLE | 프로토콜 설정 변경 | StakingProtocol |
| REWARD_POOL_ROLE | 보상 지급 | RewardPool.payUser() |
| ROUTER_ROLE | 대리 스테이킹/출금 | StakingPool.stakeFor(), withdrawAllFor() |

### 접근 제어 패턴

```solidity
// 1. 역할 기반 제어
function setProjectStatus(uint projectID, bool isActive) 
    external onlyRole(DEFAULT_ADMIN_ROLE)

// 2. 생성자 전용
function fundProjectSeason(uint projectID, uint season, address token, uint amount) 
    external 
{
    require(msg.sender == project.creator, "Only project creator");
}

// 3. 컨트랙트 전용
function payUser(address user, uint season, address token, uint userPoints, uint totalPoints)
    external onlyRole(STAKING_POOL_ROLE)
```

## 확장 아키텍처

### Addon 시스템

**구조:**
```
StakingPool
    ↓ 이벤트 발생 (stake, withdraw, season end)
    ↓ 안전 호출
IStakingAddon
    ↓ 콜백 처리
RankingAddon / 커스텀 Addon
```

**안전 호출 메커니즘:**
```solidity
function _callAddonSafe(IStakingAddon addon, bytes memory data) {
    try this.callAddon(addon, data) {}
    catch Error(string memory reason) {
        emit AddonCallFailed(addon, bytes4(data), reason);
    }
}
```

**특징:**
- Addon 실패 시에도 메인 로직 계속 진행
- 이벤트로 실패 기록
- Allowlist 기반 승인 시스템

### Hook 패턴

**스테이킹 Hook:**
```solidity
_beforeStake(user, amount, oldBalance)  // 검증 로직 추가 가능
_afterStake(user, amount, newBalance)    // 부가 처리 (Addon 호출 등)
```

**출금 Hook:**
```solidity
_beforeWithdraw(user, amount)           // 출금 제한 로직 가능
_afterWithdraw(user, amount, recipient)  // 출금 후 처리
```

**보상 Hook:**
```solidity
_beforeFundSeason(season, token, amount)
_afterFundSeason(season, token, amount)
_calculateBonusReward(...)              // 추가 보상 계산
_beforePayUser(user, season, token, amount)
_afterPayUser(user, season, token, amount)
```

## 가스 최적화 아키텍처

### 1. Transient Storage (EIP-1153)
```solidity
abstract contract ReentrancyGuardTransient
```
- 재진입 방지를 위해 transient storage 사용
- 영구 스토리지 대비 가스 절약

### 2. O(1) 집계 시스템
```
일반적인 방법:
Σ(각 유저의 포인트) → O(N) 복잡도

최적화된 방법:
Σ(총 스테이킹 × 시간 구간) → O(1) 복잡도
```

### 3. 지연 평가
```
즉시 처리: 모든 유저의 시즌 데이터 업데이트 → 높은 가스
지연 처리: 필요 시점에만 계산 → 낮은 가스
```

### 4. Unchecked 산술
```solidity
for (uint i = startSeason; i < currentSeason;) {
    _ensureUserSeasonSnapshot(user, i);
    unchecked { ++i; }  // 오버플로우 불가능
}
```

### 5. Immutable 변수
```solidity
IERC20 public immutable stakingToken;
uint public immutable projectID;
IStakingProtocol public immutable protocol;
```
- 배포 시 코드에 하드코딩
- 런타임에 스토리지 읽기 불필요

## 보안 아키텍처

### 다층 방어

1. **입력 검증 계층**
```solidity
_validateAddress(addr)   // 0 주소 차단
_validateAmount(amount)  // 0 금액 차단
_validateRange(value, min, max) // 범위 검증
```

2. **접근 제어 계층**
```solidity
onlyRole(ROLE)           // 역할 기반 제어
require(msg.sender == creator) // 소유자 전용
```

3. **재진입 방어 계층**
```solidity
nonReentrant             // 모든 외부 호출에 적용
```

4. **SafeERC20 계층**
```solidity
safeTransfer()
safeTransferFrom()
safeIncreaseAllowance()
```

### 중요 불변 조건 (Invariants)

1. **잔액 불변:**
```
Σ(userStakes[user].balance) = totalStaked
```

2. **보상 불변:**
```
seasonClaimed[season][token] ≤ seasonRewards[season][token]
```

3. **시즌 불변:**
```
season.totalPoints ≥ Σ(userSeasonData[season][user].points)
```

4. **포인트 불변:**
```
포인트 = balance × 시간 (단조 증가)
```

## 다음 문서

- [02-핵심개념.md](./02-핵심개념.md): 핵심 개념 심화
- [03-컨트랙트상세.md](./03-컨트랙트상세.md): 함수별 상세 설명

