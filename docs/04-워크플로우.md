# 사용 시나리오 및 워크플로우

## 시나리오 1: 프로젝트 생성 및 운영

### 1.1 프로젝트 생성자 관점

**목표:** 자신의 프로젝트를 위한 스테이킹 풀 생성

**단계:**

```solidity
// 1. StakingProtocol 인스턴스 가져오기
IStakingProtocol protocol = IStakingProtocol(protocolAddress);

// 2. 프로젝트 생성
uint firstSeasonStart = block.number + 100_000;  // 10만 블록 후
(uint projectID, address stakingPool, address rewardPool) = 
    protocol.createProject(
        "My DeFi Project",      // 프로젝트 이름
        0,                      // 기본 시즌 길이 사용 (30일)
        firstSeasonStart,       // 첫 시즌 시작
        0                       // 종료 없음 (무한)
    );

// 3. 프로젝트 정보 확인
IStakingProtocol.ProjectInfo memory project = protocol.getProject(projectID);
console.log("StakingPool:", project.stakingPool);
console.log("RewardPool:", project.rewardPool);
```

**결과:**
- 프로젝트 ID 할당 (예: 1)
- StakingPool 배포
- RewardPool 배포
- 프로젝트 활성화

### 1.2 시즌 1 보상 준비

**목표:** 첫 시즌에 보상 토큰 예치

```solidity
// 1. 보상 토큰 준비 (예: 프로젝트 토큰)
IERC20 rewardToken = IERC20(myProjectToken);

// 2. 시즌 1에 보상 예치
uint season1RewardAmount = 10_000 * 1e18;  // 10,000 토큰
rewardToken.approve(address(protocol), season1RewardAmount);

protocol.fundProjectSeason(
    projectID,
    1,                          // 시즌 1
    address(rewardToken),
    season1RewardAmount
);

// 3. 예치 확인
IRewardPool rewardPool = IRewardPool(project.rewardPool);
uint totalReward = rewardPool.seasonRewards(1, address(rewardToken));
console.log("Season 1 Total Reward:", totalReward);
```

**타이밍:**
- 시즌 시작 전에 예치 (권장)
- 시즌 중에도 예치 가능
- 여러 번 나누어 예치 가능

### 1.3 시즌 진행 모니터링

**목표:** 시즌 진행 상황 추적

```solidity
// 1. 현재 시즌 정보
IStakingPool pool = IStakingPool(project.stakingPool);
(uint season, uint startBlock, uint endBlock, uint blocksElapsed) = 
    pool.getCurrentSeasonInfo();

console.log("Current Season:", season);
console.log("Blocks Elapsed:", blocksElapsed);
console.log("Blocks Remaining:", endBlock - block.number);

// 2. 총 스테이킹 확인
uint totalStaked = pool.totalStaked();
console.log("Total Staked:", totalStaked);

// 3. 시즌 총 포인트 (실시간)
uint totalPoints = pool.seasonTotalPointsSnapshot(season);
console.log("Total Points:", totalPoints);

// 4. 스테이커 수
(, uint stakerCount) = pool.getStakers(0, 0);
console.log("Total Stakers:", stakerCount);
```

### 1.4 시즌 2, 3 보상 준비

**목표:** 지속적인 보상 제공

```solidity
// 여러 시즌에 미리 예치 가능
for (uint season = 2; season <= 5; season++) {
    rewardToken.approve(address(protocol), season1RewardAmount);
    protocol.fundProjectSeason(
        projectID,
        season,
        address(rewardToken),
        season1RewardAmount
    );
}

console.log("Funded seasons 2-5");
```

### 1.5 추가 토큰 보상

**목표:** 다양한 토큰으로 보상 제공

```solidity
// 같은 시즌에 여러 토큰 예치 가능
IERC20 bonusToken = IERC20(bonusTokenAddress);
bonusToken.approve(project.rewardPool, 1000 * 1e18);

IRewardPool(project.rewardPool).fundSeason(
    1,                          // 시즌 1
    address(bonusToken),       // 보너스 토큰
    1000 * 1e18
);
```

---

## 시나리오 2: 일반 사용자 스테이킹

### 2.1 Native CROSS로 스테이킹 (권장)

**목표:** 가장 간단한 방법으로 스테이킹

```solidity
// StakingRouter 사용
IStakingRouter router = IStakingRouter(routerAddress);

// Native CROSS 전송만으로 스테이킹
uint projectID = 1;
uint stakeAmount = 100 ether;  // 100 CROSS

router.stake{value: stakeAmount}(projectID);

// 자동으로:
// 1. Native CROSS → WCROSS 변환
// 2. WCROSS approve
// 3. StakingPool.stakeFor() 호출
// 4. 포인트 누적 시작
```

**결과:**
- 100 CROSS 스테이킹 완료
- 포인트 누적 시작
- 현재 시즌에 참여

### 2.2 WCROSS로 직접 스테이킹 (고급)

**목표:** 이미 WCROSS를 보유한 경우

```solidity
// WCROSS 준비
IWCROSS wcross = IWCROSS(wcrossAddress);
IStakingPool pool = IStakingPool(stakingPoolAddress);

// 1. Native CROSS → WCROSS (필요 시)
wcross.deposit{value: 100 ether}();

// 2. StakingPool에 approve
wcross.approve(address(pool), 100 ether);

// 3. 직접 스테이킹
pool.stake(100 ether);
```

**언제 사용?**
- 이미 WCROSS 보유
- 스마트 컨트랙트 통합
- 가스 최적화 필요 시

### 2.3 스테이킹 정보 확인

**목표:** 내 스테이킹 현황 조회

```solidity
address user = msg.sender;

// Router를 통한 조회 (간편)
(uint balance, uint points, uint lastUpdateBlock) = 
    router.getStakeInfo(projectID, user);

console.log("Staked:", balance);
console.log("Current Points:", points);

// 현재 시즌 정보
(uint season, uint startBlock, uint endBlock, uint blocksElapsed) = 
    router.getSeasonInfo(projectID);

console.log("Season:", season);
console.log("Remaining Blocks:", endBlock - block.number);

// 예상 보상
uint expectedReward = router.getExpectedSeasonReward(
    projectID,
    season,
    user,
    rewardTokenAddress
);
console.log("Expected Reward:", expectedReward);
```

### 2.4 추가 스테이킹

**목표:** 기존 스테이킹에 추가

```solidity
// 추가로 50 CROSS 스테이킹
router.stake{value: 50 ether}(projectID);

// 자동으로:
// 1. 기존 포인트 업데이트
// 2. 잔액 증가 (100 → 150)
// 3. 새로운 포인트 누적 시작
```

**효과:**
- 기존 포인트 보존
- 새 금액으로 포인트 누적
- 시즌 참여 계속

### 2.5 시즌 종료 대기

**목표:** 시즌 종료 후 보상 청구 준비

```solidity
// 시즌 종료 확인
bool isActive = router.isSeasonActive(projectID);

if (!isActive) {
    console.log("Season ended, can claim rewards");
    
    // 청구 미리보기
    (
        uint expectedReward,
        uint userPoints,
        uint totalPoints,
        bool alreadyClaimed
    ) = router.previewClaim(
        projectID,
        user,
        1,  // 시즌 1
        rewardTokenAddress
    );
    
    console.log("My Points:", userPoints);
    console.log("Total Points:", totalPoints);
    console.log("My Share:", userPoints * 100 / totalPoints, "%");
    console.log("Expected Reward:", expectedReward);
}
```

### 2.6 보상 청구

**목표:** 종료된 시즌의 보상 받기

```solidity
// 단일 청구
router.claimReward(
    projectID,
    1,  // 시즌 1
    rewardTokenAddress
);

// 보상 토큰이 사용자에게 전송됨
uint balance = IERC20(rewardTokenAddress).balanceOf(user);
console.log("Received Reward:", balance);
```

**여러 시즌 일괄 청구:**
```solidity
uint[] memory seasons = new uint[](3);
seasons[0] = 1;
seasons[1] = 2;
seasons[2] = 3;

address[] memory tokens = new address[](3);
tokens[0] = address(tokenA);
tokens[1] = address(tokenA);
tokens[2] = address(tokenB);

// 한 번에 청구
router.claimMultipleRewards(projectID, seasons, tokens);
```

### 2.7 출금

**목표:** 스테이킹 종료 및 토큰 회수

```solidity
// Native CROSS로 전액 출금
router.unstake(projectID);

// 자동으로:
// 1. StakingPool에서 출금
// 2. WCROSS → Native CROSS 변환
// 3. Native CROSS 전송
// 4. 현재 시즌 포인트 소멸 (주의!)

// 이전 시즌 보상은 여전히 청구 가능
```

**주의사항:**
- 전액 출금만 가능 (부분 출금 불가)
- 현재 시즌 포인트 소멸
- 이전 시즌 보상은 청구 가능
- 출금 후 다시 스테이킹 가능

---

## 시나리오 3: 장기 스테이킹 전략

### 3.1 복수 시즌 참여

**목표:** 여러 시즌에 걸쳐 최대 보상 획득

**전략:**

```solidity
// 시즌 1 시작 전에 스테이킹 (최적)
router.stake{value: 1000 ether}(projectID);

// 시즌 1 전체 참여
// 블록 1000-3000: 포인트 = 1000 × 2000 블록

// 시즌 2 자동 전환
// 스테이킹 유지하면 자동으로 시즌 2 참여
// 블록 3001-5000: 포인트 = 1000 × 2000 블록

// 시즌 3, 4, 5...
// 계속 참여
```

**장점:**
- 모든 시즌 참여
- 최대 포인트 획득
- 복리 효과

### 3.2 전략적 청구 시점

**시나리오:**
```
시즌 1: 1000 CROSS 스테이킹
시즌 2: 계속 유지
시즌 3: 계속 유지
시즌 4: 출금 예정
```

**최적 청구 전략:**
```solidity
// 시즌 2 종료 후
router.claimReward(projectID, 1, tokenAddress);  // 시즌 1 청구

// 시즌 3 종료 후
router.claimReward(projectID, 2, tokenAddress);  // 시즌 2 청구

// 시즌 4 종료 후 (출금 전)
router.claimReward(projectID, 3, tokenAddress);  // 시즌 3 청구

// 출금
router.unstake(projectID);

// 나중에 시즌 4도 청구 가능 (출금 후에도)
router.claimReward(projectID, 4, tokenAddress);
```

### 3.3 다중 프로젝트 분산

**목표:** 여러 프로젝트에 분산 투자

```solidity
// 프로젝트 A: 500 CROSS
router.stake{value: 500 ether}(projectA);

// 프로젝트 B: 300 CROSS
router.stake{value: 300 ether}(projectB);

// 프로젝트 C: 200 CROSS
router.stake{value: 200 ether}(projectC);

// 전체 포트폴리오 조회
uint[] memory projectIDs = new uint[](3);
projectIDs[0] = projectA;
projectIDs[1] = projectB;
projectIDs[2] = projectC;

(
    uint[] memory balances,
    uint[] memory points,
    uint[] memory seasons
) = router.getUserStakingSummary(user, projectIDs);

// 각 프로젝트별 현황 확인
for (uint i = 0; i < 3; i++) {
    console.log("Project", projectIDs[i]);
    console.log("  Balance:", balances[i]);
    console.log("  Points:", points[i]);
    console.log("  Season:", seasons[i]);
}
```

---

## 시나리오 4: 고급 사용 패턴

### 4.1 가스 최적화: 시즌 배치 처리

**문제:** 오랜 기간 스테이킹 후 첫 트랜잭션 시 높은 가스

**해결:**
```solidity
// 사용자가 10개 시즌 동안 스테이킹했다면
// 첫 트랜잭션에서 모든 시즌 스냅샷 생성 (높은 가스)

// 해결책: 배치로 미리 처리
uint maxSeasonsPerTx = 5;

// 첫 번째 배치
uint processed1 = pool.finalizeUserSeasonsBatch(user, maxSeasonsPerTx);
// 시즌 1-5 처리

// 두 번째 배치
uint processed2 = pool.finalizeUserSeasonsBatch(user, maxSeasonsPerTx);
// 시즌 6-10 처리

// 이후 청구 시 가스 절약
pool.claimSeason(1, tokenAddress);  // 낮은 가스
```

**언제 사용?**
- 장기간 미사용 계정
- 많은 시즌 누적
- 가스 최적화 필요 시

### 4.2 청구 미리보기 및 검증

**목표:** 청구 전 상세 정보 확인

```solidity
// 1. 시즌 데이터 확인
(
    uint points,
    uint balance,
    uint joinBlock,
    bool claimed,
    bool finalized
) = router.getUserSeasonData(projectID, user, 1);

console.log("Season 1 Data:");
console.log("  Points:", points);
console.log("  Balance:", balance);
console.log("  Join Block:", joinBlock);
console.log("  Claimed:", claimed);
console.log("  Finalized:", finalized);

// 2. 청구 미리보기
(
    uint expectedReward,
    uint userPoints,
    uint totalPoints,
    bool alreadyClaimed
) = router.previewClaim(projectID, user, 1, tokenAddress);

if (alreadyClaimed) {
    console.log("Already claimed!");
    return;
}

console.log("Preview:");
console.log("  My Points:", userPoints);
console.log("  Total Points:", totalPoints);
console.log("  My Share:", userPoints * 10000 / totalPoints / 100, "%");
console.log("  Expected:", expectedReward);

// 3. 실제 청구
if (expectedReward > 0) {
    router.claimReward(projectID, 1, tokenAddress);
}
```

### 4.3 여러 토큰 보상 관리

**시나리오:** 한 시즌에 여러 토큰 보상

```solidity
// 프로젝트에서 제공하는 보상 토큰 목록
address[] memory rewardTokens = new address[](3);
rewardTokens[0] = projectToken;
rewardTokens[1] = bonusToken;
rewardTokens[2] = partnerToken;

// 시즌 1의 모든 토큰 보상 확인
for (uint i = 0; i < rewardTokens.length; i++) {
    uint reward = router.getClaimableReward(
        projectID,
        user,
        1,
        rewardTokens[i]
    );
    
    if (reward > 0) {
        console.log("Token", i, "Reward:", reward);
        
        // 청구
        router.claimReward(projectID, 1, rewardTokens[i]);
    }
}
```

### 4.4 시즌 히스토리 분석

**목표:** 과거 시즌 데이터 분석

```solidity
// 시즌 1-10의 총 포인트 추이
(
    uint[] memory seasons,
    uint[] memory totalPoints
) = router.getSeasonHistory(projectID, 1, 10);

for (uint i = 0; i < seasons.length; i++) {
    console.log("Season", seasons[i]);
    console.log("  Total Points:", totalPoints[i]);
    
    // APY 계산 등에 활용 가능
}
```

---

## 시나리오 5: 프로젝트 관리자 고급 운영

### 5.1 시즌 타이밍 조정

**목표:** 특정 블록에 시즌 시작

```solidity
// 프로토콜 관리자가 실행
uint targetBlock = block.number + 1_000_000;

protocol.setPoolNextSeasonStart(projectID, targetBlock);

// 현재 시즌이 종료되면 targetBlock에서 시작
```

### 5.2 Addon 연결

**목표:** 랭킹 기능 추가

```solidity
// 1. RankingAddon 배포
RankingAddon addon = new RankingAddon(stakingPool);

// 2. Addon 승인 (allowlist)
protocol.setPoolAddonApproved(projectID, IStakingAddon(address(addon)), true);

// 3. Addon 설정
protocol.setPoolStakingAddon(projectID, IStakingAddon(address(addon)));

// 이제 스테이킹 시 자동으로 랭킹 업데이트
```

### 5.3 긴급 풀 종료

**목표:** 프로젝트 종료 시점 설정

```solidity
// 100만 블록 후 풀 종료
uint endBlock = block.number + 1_000_000;

protocol.setPoolEndBlock(projectID, endBlock);

// endBlock 이후:
// - 새로운 시즌 시작 안 됨
// - 기존 스테이킹 유지
// - 출금은 가능
// - 마지막 시즌 보상 청구 가능
```

### 5.4 보상 잔액 관리

**목표:** 시즌별 보상 현황 파악

```solidity
IRewardPool rewardPool = IRewardPool(project.rewardPool);

address[] memory tokens = new address[](2);
tokens[0] = tokenA;
tokens[1] = tokenB;

// 시즌 1 보상 요약
(
    uint[] memory totals,
    uint[] memory claimed,
    uint[] memory remaining
) = rewardPool.getSeasonSummary(1, tokens);

for (uint i = 0; i < tokens.length; i++) {
    console.log("Token:", tokens[i]);
    console.log("  Total:", totals[i]);
    console.log("  Claimed:", claimed[i]);
    console.log("  Remaining:", remaining[i]);
    console.log("  Claim Rate:", claimed[i] * 100 / totals[i], "%");
}
```

---

## 시나리오 6: 스마트 컨트랙트 통합

### 6.1 자동 재스테이킹 컨트랙트

**목표:** 보상을 자동으로 재스테이킹

```solidity
contract AutoRestake {
    IStakingRouter public router;
    uint public projectID;
    
    function claimAndRestake(uint season, address rewardToken) external {
        // 1. 보상 청구
        router.claimReward(projectID, season, rewardToken);
        
        // 2. 받은 토큰 확인
        uint balance = IERC20(rewardToken).balanceOf(address(this));
        
        // 3. 토큰이 WCROSS라면 재스테이킹
        if (rewardToken == address(router.wcross())) {
            IERC20(rewardToken).approve(
                address(router.protocol().projects(projectID).stakingPool),
                balance
            );
            IStakingPool(
                router.protocol().projects(projectID).stakingPool
            ).stake(balance);
        }
    }
}
```

### 6.2 볼트 컨트랙트

**목표:** 사용자 자금을 모아 대규모 스테이킹

```solidity
contract StakingVault {
    IStakingRouter public router;
    uint public projectID;
    
    mapping(address => uint) public userShares;
    uint public totalShares;
    
    function deposit() external payable {
        // 사용자 입금
        uint shares = msg.value;  // 1:1 비율
        userShares[msg.sender] += shares;
        totalShares += shares;
        
        // 즉시 스테이킹
        router.stake{value: msg.value}(projectID);
    }
    
    function withdraw() external {
        uint shares = userShares[msg.sender];
        require(shares > 0, "No shares");
        
        // 비율 계산
        uint stakingPool = router.protocol().projects(projectID).stakingPool;
        (uint totalStaked,,) = router.getStakeInfo(projectID, address(this));
        
        uint userAmount = totalStaked * shares / totalShares;
        
        // 부분 출금 처리 (커스텀 로직 필요)
        // ...
    }
    
    function claimRewards(uint season, address token) external {
        // 볼트가 보상 청구
        router.claimReward(projectID, season, token);
        
        // 사용자별 분배는 별도 로직
        // ...
    }
}
```

### 6.3 조건부 스테이킹

**목표:** 특정 조건 충족 시 자동 스테이킹

```solidity
contract ConditionalStaking {
    IStakingRouter public router;
    uint public projectID;
    
    function autoStakeIfAPYAbove(uint minAPY) external payable {
        // 현재 APY 계산 (간단화)
        uint currentSeason = router.getCurrentSeason(projectID);
        uint totalStaked = router.getTotalStaked(projectID);
        uint totalReward = IRewardPool(
            router.protocol().projects(projectID).rewardPool
        ).seasonRewards(currentSeason, rewardToken);
        
        // APY = (보상 / 총 스테이킹) × (365 / 시즌 길이)
        uint apy = totalReward * 365 * 100 / totalStaked / 30;  // 간단화
        
        if (apy >= minAPY) {
            router.stake{value: msg.value}(projectID);
        } else {
            // 조건 미충족 시 반환
            payable(msg.sender).transfer(msg.value);
        }
    }
}
```

---

## 가스 비용 가이드

### 일반적인 가스 비용

| 작업 | 예상 가스 | 비고 |
|-----|----------|------|
| 프로젝트 생성 | ~2,500,000 | 두 컨트랙트 배포 |
| 첫 스테이킹 | ~200,000 | 새 사용자 등록 |
| 추가 스테이킹 | ~150,000 | 기존 사용자 |
| 출금 | ~150,000 | 기본 |
| 시즌 롤오버 | ~100,000 | 첫 트랜잭션 시 |
| 보상 청구 (첫 시즌) | ~120,000 | 스냅샷 생성 |
| 보상 청구 (이후) | ~80,000 | 스냅샷 이미 존재 |
| 보상 예치 | ~70,000 | fundSeason |

### 가스 최적화 팁

1. **배치 처리 사용**
```solidity
// 나쁜 예: 여러 트랜잭션
router.claimReward(projectID, 1, token);
router.claimReward(projectID, 2, token);
router.claimReward(projectID, 3, token);

// 좋은 예: 한 트랜잭션
uint[] memory seasons = [1, 2, 3];
address[] memory tokens = [token, token, token];
router.claimMultipleRewards(projectID, seasons, tokens);
```

2. **시즌 배치 처리**
```solidity
// 많은 시즌 누적 시 미리 처리
pool.finalizeUserSeasonsBatch(user, 10);
```

3. **조회 함수 활용**
```solidity
// 청구 전 확인
(uint reward,,,) = router.previewClaim(projectID, user, season, token);
if (reward == 0) return;  // 불필요한 트랜잭션 방지
```

---

## 다음 문서

- [05-기술구현.md](./05-기술구현.md): 기술적 구현 디테일

