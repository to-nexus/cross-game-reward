# ê¸°ìˆ  êµ¬í˜„ ë””í…Œì¼

## 1. Code ì»¨íŠ¸ë™íŠ¸ íŒ¨í„´

### 1.1 ë¬¸ì œ: ì»¨íŠ¸ë™íŠ¸ í¬ê¸° ì œí•œ

**Ethereum ì œì•½:**
- ì»¨íŠ¸ë™íŠ¸ ìµœëŒ€ í¬ê¸°: 24KB (EIP-170)
- StakingProtocol + StakingPool + RewardPool = í¬ê¸° ì´ˆê³¼

### 1.2 í•´ê²°: Code íŒ¨í„´

**ê°œë…:**
```
StakingPoolCode ì»¨íŠ¸ë™íŠ¸:
- StakingPoolì˜ creation codeë§Œ ì €ì¥
- code() í•¨ìˆ˜ë¡œ ë°˜í™˜

StakingProtocol:
- Code ì»¨íŠ¸ë™íŠ¸ì—ì„œ creation code ê°€ì ¸ì˜¤ê¸°
- Constructor ì¸ìì™€ ê²°í•©
- CREATE opcodeë¡œ ë°°í¬
```

**êµ¬í˜„:**

```solidity
// Code ì»¨íŠ¸ë™íŠ¸
contract StakingPoolCode {
    function code() external pure returns (bytes memory) {
        return type(StakingPool).creationCode;
    }
}

// Factoryì—ì„œ ì‚¬ìš©
function _deployStakingPool(...) internal returns (address pool) {
    // 1. Code ê°€ì ¸ì˜¤ê¸°
    bytes memory code = _getStakingPoolCode();
    
    // 2. Constructor ì¸ì ì¸ì½”ë”©
    bytes memory constructorArgs = abi.encode(
        projectID,
        address(_crossToken),
        address(this),
        seasonBlocks,
        firstSeasonStartBlock,
        poolEndBlock
    );
    
    // 3. ê²°í•©
    bytes memory bytecode = bytes.concat(code, constructorArgs);
    
    // 4. ë°°í¬
    assembly {
        pool := create(0, add(bytecode, 0x20), mload(bytecode))
    }
    
    require(pool != address(0), "Deployment failed");
}
```

**ì¥ì :**
1. Factory í¬ê¸° ê°ì†Œ
2. ì—…ê·¸ë ˆì´ë“œ ìš©ì´ì„±
3. ë°°í¬ ë¹„ìš© ìµœì í™”

### 1.3 ë™ì  staticcall íŒ¨í„´

```solidity
function _getStakingPoolCode() internal view returns (bytes memory) {
    (bool success, bytes memory code) = 
        stakingPoolCodeContract.staticcall(
            abi.encodeWithSignature("code()")
        );
    
    require(success, "Failed to get code");
    return abi.decode(code, (bytes));
}
```

---

## 2. O(1) ì‹œì¦Œ ì§‘ê³„ ì‹œìŠ¤í…œ

### 2.1 ë¬¸ì œ ë¶„ì„

**ë‹¨ìˆœ êµ¬í˜„ (O(N)):**
```solidity
function getTotalPoints(uint season) public view returns (uint) {
    uint total = 0;
    for (uint i = 0; i < stakers.length; i++) {
        total += userSeasonData[season][stakers[i]].points;
    }
    return total;
}

// ë¬¸ì œ:
// - ìŠ¤í…Œì´ì»¤ 1000ëª… â†’ 1000ë²ˆ ë£¨í”„
// - ê°€ìŠ¤ ë¹„ìš© ë§¤ìš° ë†’ìŒ
// - ë¸”ë¡ ê°€ìŠ¤ í•œë„ ì´ˆê³¼ ê°€ëŠ¥
```

### 2.2 ìˆ˜í•™ì  ìµœì í™”

**í•µì‹¬ ì•„ì´ë””ì–´:**
```
ëª¨ë“  ìœ ì €ì˜ í¬ì¸íŠ¸ í•©:
Î£(ìœ ì €ë³„ ì”ì•¡ Ã— ì‹œê°„) = (ëª¨ë“  ìœ ì € ì”ì•¡ì˜ í•©) Ã— ì‹œê°„
                        = ì´ ìŠ¤í…Œì´í‚¹ Ã— ì‹œê°„
```

**ì¦ëª…:**
```
3ëª…ì˜ ìœ ì €:
- Alice: 50 CROSS, 100 ë¸”ë¡ â†’ 5,000 í¬ì¸íŠ¸
- Bob: 30 CROSS, 100 ë¸”ë¡ â†’ 3,000 í¬ì¸íŠ¸
- Charlie: 20 CROSS, 100 ë¸”ë¡ â†’ 2,000 í¬ì¸íŠ¸

ê°œë³„ í•©ê³„: 5,000 + 3,000 + 2,000 = 10,000

ì§‘ê³„ ê³„ì‚°: (50 + 30 + 20) Ã— 100 = 100 Ã— 100 = 10,000 âœ“
```

### 2.3 êµ¬í˜„

**Season êµ¬ì¡°ì²´:**
```solidity
struct Season {
    uint seasonNumber;
    uint startBlock;
    uint endBlock;
    bool isFinalized;
    uint totalPoints;           // ìµœì¢… ì´ í¬ì¸íŠ¸ (ìºì‹œ)
    uint seasonTotalStaked;     // ì§‘ê³„ìš© ì´ ìŠ¤í…Œì´í‚¹
    uint lastAggregatedBlock;   // ë§ˆì§€ë§‰ ì§‘ê³„ ë¸”ë¡
    uint aggregatedPoints;      // ëˆ„ì  ì§‘ê³„ í¬ì¸íŠ¸
}
```

**ì¦ë¶„ ì—…ë°ì´íŠ¸:**
```solidity
function _updateSeasonAggregation(uint seasonNum) internal {
    Season storage season = seasons[seasonNum];
    
    // ì´ë¯¸ ìµœì‹ ì´ë©´ ìŠ¤í‚µ
    if (season.lastAggregatedBlock >= block.number) return;
    
    // ì´ ìŠ¤í…Œì´í‚¹ì´ 0ì´ë©´ ì‹œê°„ë§Œ ì—…ë°ì´íŠ¸
    if (season.seasonTotalStaked == 0) {
        season.lastAggregatedBlock = block.number;
        return;
    }
    
    // ì¦ë¶„ í¬ì¸íŠ¸ ê³„ì‚°
    uint additionalPoints = PointsLib.calculatePoints(
        season.seasonTotalStaked,
        season.lastAggregatedBlock,
        block.number,
        blockTime,
        pointsTimeUnit
    );
    
    // ëˆ„ì 
    season.aggregatedPoints += additionalPoints;
    season.lastAggregatedBlock = block.number;
}
```

**ìŠ¤í…Œì´í‚¹ ì‹œ ì—…ë°ì´íŠ¸:**
```solidity
function _stakeFor(...) internal {
    // ... ê¸°ì¡´ ë¡œì§ ...
    
    // ì§‘ê³„ ì—…ë°ì´íŠ¸ (í˜„ì¬ê¹Œì§€)
    _updateSeasonAggregation(currentSeason);
    
    // ì´ ìŠ¤í…Œì´í‚¹ ì¦ê°€
    currentSeasonData.seasonTotalStaked += amount;
    
    // ì´í›„ ë¸”ë¡ë¶€í„° ìƒˆë¡œìš´ ì´ëŸ‰ìœ¼ë¡œ ê³„ì‚°ë¨
}
```

**ì‹œë®¬ë ˆì´ì…˜:**
```
ë¸”ë¡ 1000: ì‹œì¦Œ ì‹œì‘
- seasonTotalStaked: 0
- aggregatedPoints: 0
- lastAggregatedBlock: 1000

ë¸”ë¡ 1100: Alice 100 ìŠ¤í…Œì´í‚¹
- ì§‘ê³„ ì—…ë°ì´íŠ¸: 0 Ã— (1100-1000) = 0
- seasonTotalStaked: 0 â†’ 100
- aggregatedPoints: 0
- lastAggregatedBlock: 1100

ë¸”ë¡ 1200: Bob 50 ìŠ¤í…Œì´í‚¹
- ì§‘ê³„ ì—…ë°ì´íŠ¸: 100 Ã— (1200-1100) = 10,000
- seasonTotalStaked: 100 â†’ 150
- aggregatedPoints: 0 + 10,000 = 10,000
- lastAggregatedBlock: 1200

ë¸”ë¡ 1300: ì¡°íšŒ
- ì¦ë¶„: 150 Ã— (1300-1200) = 15,000
- ì´ í¬ì¸íŠ¸: 10,000 + 15,000 = 25,000

ê²€ì¦:
- Alice: 100 Ã— (1300-1100) = 20,000
- Bob: 50 Ã— (1300-1200) = 5,000
- í•©ê³„: 25,000 âœ“
```

### 2.4 ë³µì¡ë„ ë¹„êµ

| ë°©ë²• | ì‹œê°„ ë³µì¡ë„ | ê°€ìŠ¤ ë¹„ìš© | í™•ì¥ì„± |
|-----|-----------|----------|--------|
| ë‹¨ìˆœ í•©ê³„ | O(N) | N Ã— 5,000 | ìŠ¤í…Œì´ì»¤ ìˆ˜ ì œí•œ |
| ì§‘ê³„ ë°©ì‹ | O(1) | ~20,000 | ë¬´ì œí•œ |

---

## 3. ì§€ì—° ìŠ¤ëƒ…ìƒ· ì‹œìŠ¤í…œ

### 3.1 ë¬¸ì œ: ì‹œì¦Œ ì „í™˜ ì‹œ ê°€ìŠ¤ í­íƒ„

**ì¦‰ì‹œ ìŠ¤ëƒ…ìƒ· ë°©ì‹:**
```solidity
function _rolloverSeason() internal {
    // ëª¨ë“  ìŠ¤í…Œì´ì»¤ì˜ ì‹œì¦Œ ë°ì´í„° ìƒì„±
    for (uint i = 0; i < stakers.length; i++) {
        _snapshotUser(stakers[i], oldSeason);
    }
    
    // ë¬¸ì œ:
    // - ìŠ¤í…Œì´ì»¤ 1000ëª… â†’ 1000ë²ˆ ìŠ¤ëƒ…ìƒ·
    // - ê°€ìŠ¤ ë¹„ìš© ìˆ˜ë°±ë§Œ
    // - ë¸”ë¡ ê°€ìŠ¤ í•œë„ ì´ˆê³¼
    // - ì‹œì¦Œ ì „í™˜ ë¶ˆê°€ëŠ¥
}
```

### 3.2 í•´ê²°: Lazy Evaluation

**í•µì‹¬ ì•„ì´ë””ì–´:**
```
ì‹œì¦Œ ì¢…ë£Œ ì‹œ:
- ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ (O(1))

ë³´ìƒ ì²­êµ¬/ìŠ¤í…Œì´í‚¹ ì‹œ:
- í•´ë‹¹ ìœ ì €ì˜ ì´ì „ ì‹œì¦Œë§Œ ê³„ì‚°
- í•„ìš”í•œ ì‹œì¦Œë§Œ ì²˜ë¦¬
- ê°œë³„ ìœ ì €ê°€ ê°€ìŠ¤ ë¶€ë‹´
```

### 3.3 êµ¬í˜„

**UserSeasonData:**
```solidity
struct UserSeasonData {
    uint points;        // ì‹œì¦Œ í¬ì¸íŠ¸
    uint balance;       // ì‹œì¦Œ ì”ì•¡
    uint joinBlock;     // ì°¸ì—¬ ë¸”ë¡
    bool claimed;       // ì²­êµ¬ ì—¬ë¶€
    bool finalized;     // ìŠ¤ëƒ…ìƒ· ì™„ë£Œ ì—¬ë¶€
}
```

**ì§€ì—° ìŠ¤ëƒ…ìƒ·:**
```solidity
function _ensureUserAllPreviousSeasons(address user) internal {
    if (currentSeason == 0) return;
    
    // ë§ˆì§€ë§‰ìœ¼ë¡œ ì²˜ë¦¬í•œ ì‹œì¦Œ
    uint startSeason = lastFinalizedSeason[user];
    if (startSeason == 0) startSeason = 1;
    
    if (startSeason >= currentSeason) return;
    
    // ì´ì „ ì‹œì¦Œë“¤ì„ ìˆœíšŒí•˜ë©° ìŠ¤ëƒ…ìƒ·
    for (uint i = startSeason; i < currentSeason;) {
        _ensureUserSeasonSnapshot(user, i);
        unchecked { ++i; }
    }
    
    lastFinalizedSeason[user] = currentSeason - 1;
}
```

**ê°œë³„ ìŠ¤ëƒ…ìƒ·:**
```solidity
function _ensureUserSeasonSnapshot(address user, uint seasonNum) internal {
    Season storage season = seasons[seasonNum];
    
    // ì‹œì¦Œì´ ì¢…ë£Œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ìŠ¤í‚µ
    if (!season.isFinalized) return;
    
    UserSeasonData storage userData = userSeasonData[seasonNum][user];
    
    // ì´ë¯¸ ì²˜ë¦¬ëìœ¼ë©´ ìŠ¤í‚µ
    if (userData.finalized) return;
    
    StakePosition storage position = userStakes[user];
    
    // ìŠ¤í…Œì´í‚¹ì´ ì—†ì—ˆìœ¼ë©´ ìŠ¤í‚µ
    if (position.balance == 0 && userData.balance == 0) {
        userData.finalized = true;
        return;
    }
    
    // í¬ì¸íŠ¸ ê³„ì‚° (ì†Œê¸‰)
    uint balanceToUse = userData.balance > 0 
        ? userData.balance 
        : position.balance;
    
    uint joinBlockToUse = userData.joinBlock > 0 
        ? userData.joinBlock 
        : position.lastUpdateBlock;
    
    // ì‹œì¦Œ ë²”ìœ„ ë‚´ì—ì„œ í¬ì¸íŠ¸ ê³„ì‚°
    if (joinBlockToUse < season.startBlock) {
        userData.balance = balanceToUse;
        userData.joinBlock = season.startBlock;
        userData.points = PointsLib.calculatePoints(
            balanceToUse,
            season.startBlock,
            season.endBlock,
            blockTime,
            pointsTimeUnit
        );
    } else if (joinBlockToUse <= season.endBlock) {
        userData.balance = balanceToUse;
        userData.joinBlock = joinBlockToUse;
        userData.points = PointsLib.calculatePoints(
            balanceToUse,
            joinBlockToUse,
            season.endBlock,
            blockTime,
            pointsTimeUnit
        );
    }
    
    userData.finalized = true;
}
```

### 3.4 ì˜ˆì‹œ ì‹¤í–‰ íë¦„

**ì‹œë‚˜ë¦¬ì˜¤:**
```
ë¸”ë¡ 1000: ì‹œì¦Œ 1 ì‹œì‘
ë¸”ë¡ 1500: Alice 100 ìŠ¤í…Œì´í‚¹
ë¸”ë¡ 3000: ì‹œì¦Œ 1 ì¢…ë£Œ, ì‹œì¦Œ 2 ì‹œì‘
ë¸”ë¡ 3500: Alice ì¶”ê°€ ìŠ¤í…Œì´í‚¹ 50
ë¸”ë¡ 5000: ì‹œì¦Œ 2 ì¢…ë£Œ, ì‹œì¦Œ 3 ì‹œì‘
ë¸”ë¡ 5500: Alice ë³´ìƒ ì²­êµ¬ (ì‹œì¦Œ 1)
```

**íŠ¸ëœì­ì…˜ë³„ ì²˜ë¦¬:**

**ë¸”ë¡ 1500 (ì²« ìŠ¤í…Œì´í‚¹):**
```solidity
stake(100)
  â†“
_ensureUserAllPreviousSeasons(Alice)
  â†“ currentSeason = 1
  â†“ lastFinalizedSeason[Alice] = 0
  â†“ ì²˜ë¦¬í•  ì‹œì¦Œ ì—†ìŒ
  â†“
userStakes[Alice].balance = 100
userSeasonData[1][Alice].balance = 100
userSeasonData[1][Alice].joinBlock = 1500
```

**ë¸”ë¡ 3000 (ì‹œì¦Œ ì „í™˜):**
```solidity
// ìë™ ë¡¤ì˜¤ë²„
_rolloverSeason()
  â†“
seasons[1].isFinalized = true
seasons[2] ìƒì„±
  â†“
// Aliceì˜ ì‹œì¦Œ 1 ë°ì´í„°ëŠ” ì•„ì§ finalized = false
```

**ë¸”ë¡ 3500 (ì¶”ê°€ ìŠ¤í…Œì´í‚¹):**
```solidity
stake(50)
  â†“
_ensureUserAllPreviousSeasons(Alice)
  â†“ currentSeason = 2
  â†“ lastFinalizedSeason[Alice] = 0
  â†“ ì²˜ë¦¬ ë²”ìœ„: ì‹œì¦Œ 1
  â†“
_ensureUserSeasonSnapshot(Alice, 1)
  â†“ season 1 finalized = true âœ“
  â†“ userData finalized = false âœ“
  â†“ í¬ì¸íŠ¸ ê³„ì‚°: 100 Ã— (3000-1500) = 150,000
  â†“ userData[1].points = 150,000
  â†“ userData[1].finalized = true
  â†“
lastFinalizedSeason[Alice] = 1
  â†“
// ì´ì œ ì‹œì¦Œ 2ì—ì„œ ìŠ¤í…Œì´í‚¹ ê³„ì†
userStakes[Alice].balance = 150
userSeasonData[2][Alice].balance = 150
userSeasonData[2][Alice].joinBlock = 3500
```

**ë¸”ë¡ 5500 (ë³´ìƒ ì²­êµ¬):**
```solidity
claimSeason(1, token)
  â†“
_ensureUserSeasonSnapshot(Alice, 1)
  â†“ ì´ë¯¸ finalized = true
  â†“ ìŠ¤í‚µ
  â†“
uint userPoints = userSeasonData[1][Alice].points  // 150,000
uint totalPoints = seasons[1].totalPoints
  â†“
rewardPool.payUser(Alice, 1, token, userPoints, totalPoints)
```

### 3.5 ê°€ìŠ¤ ë¹„ìš© ë¶„ì„

| ì‹œë‚˜ë¦¬ì˜¤ | ì¦‰ì‹œ ìŠ¤ëƒ…ìƒ· | ì§€ì—° ìŠ¤ëƒ…ìƒ· |
|---------|-----------|-----------|
| ì‹œì¦Œ ì „í™˜ | O(N) Ã— 100,000 | O(1) Ã— 20,000 |
| ì²« ì²­êµ¬ (10 ì‹œì¦Œ) | 0 | 10 Ã— 20,000 = 200,000 |
| ì´í›„ ì²­êµ¬ | 80,000 | 80,000 |
| ì´í•© (ë¯¸ì²­êµ¬ í¬í•¨) | O(N) Ã— 100,000 | ê°œë³„ ë¶€ë‹´ |

**ì¥ì :**
- ì‹œì¦Œ ì „í™˜ í•­ìƒ ì„±ê³µ
- ë¯¸ì²­êµ¬ ìœ ì €ëŠ” ê°€ìŠ¤ ë¶€ë‹´ ì—†ìŒ
- í™•ì¥ì„± ë¬´í•œëŒ€

---

## 4. Transient ì¬ì§„ì… ë°©ì§€ (EIP-1153)

### 4.1 ê¸°ì¡´ ë°©ì‹ì˜ ë¬¸ì œ

**ì˜êµ¬ ìŠ¤í† ë¦¬ì§€ ë°©ì‹:**
```solidity
contract ReentrancyGuard {
    uint256 private _status;
    
    modifier nonReentrant() {
        require(_status != 2, "ReentrancyGuard: reentrant call");
        _status = 2;  // SSTORE (20,000 ê°€ìŠ¤)
        _;
        _status = 1;  // SSTORE (20,000 ê°€ìŠ¤)
    }
}

// ë¹„ìš©: 40,000 ê°€ìŠ¤
```

### 4.2 Transient Storage (EIP-1153)

**ê°œë…:**
- íŠ¸ëœì­ì…˜ ìˆ˜ëª… ë™ì•ˆë§Œ ìœ íš¨
- íŠ¸ëœì­ì…˜ ì¢…ë£Œ ì‹œ ìë™ ì‚­ì œ
- ì €ì¥ ë¹„ìš© ë‚®ìŒ

**OpenZeppelin êµ¬í˜„:**
```solidity
abstract contract ReentrancyGuardTransient {
    // íŠ¸ëœì­ì…˜ ë™ì•ˆë§Œ ìœ íš¨í•œ ìŠ¤í† ë¦¬ì§€
    uint256 private constant NOT_ENTERED = 0;
    uint256 private constant ENTERED = 1;
    
    modifier nonReentrant() {
        require(_reentrancyGuardEntered() == NOT_ENTERED);
        _setReentrancyGuardEntered(ENTERED);
        _;
        _setReentrancyGuardEntered(NOT_ENTERED);
    }
    
    function _reentrancyGuardEntered() private view returns (uint256) {
        uint256 value;
        assembly {
            value := tload(0)  // TLOAD (100 ê°€ìŠ¤)
        }
        return value;
    }
    
    function _setReentrancyGuardEntered(uint256 value) private {
        assembly {
            tstore(0, value)  // TSTORE (100 ê°€ìŠ¤)
        }
    }
}

// ë¹„ìš©: 200 ê°€ìŠ¤ (200ë°° ì ˆì•½!)
```

### 4.3 ì ìš©

```solidity
abstract contract CrossStakingBase is 
    AccessControlDefaultAdminRules,
    ReentrancyGuardTransient  // â† Transient ì‚¬ìš©
{
    // ...
}

// ëª¨ë“  í•˜ìœ„ ì»¨íŠ¸ë™íŠ¸ì— ì ìš©
contract StakingPool is StakingPoolBase {
    function stake(uint amount) external nonReentrant { ... }
    function withdrawAll() external nonReentrant { ... }
    function claimSeason(...) external nonReentrant { ... }
}
```

---

## 5. SafeERC20ê³¼ í† í° ì•ˆì „ì„±

### 5.1 ë¬¸ì œ: ë¹„í‘œì¤€ ERC20 í† í°

**ì¼ë°˜ì ì¸ ë¬¸ì œë“¤:**
```solidity
// 1. ë°˜í™˜ê°’ ì—†ìŒ (USDT)
function transfer(address to, uint amount);  // bool ë°˜í™˜ ì•ˆ í•¨

// 2. revert ëŒ€ì‹  false ë°˜í™˜
function transfer(address to, uint amount) returns (bool) {
    if (balanceOf[msg.sender] < amount) return false;  // revert ì•ˆ í•¨
}

// 3. ìˆ˜ìˆ˜ë£Œ í† í°
function transfer(address to, uint amount) returns (bool) {
    uint fee = amount / 100;
    balanceOf[to] += amount - fee;  // ë°›ëŠ” ê¸ˆì•¡ì´ ë‹¤ë¦„
}
```

### 5.2 SafeERC20 ì‚¬ìš©

```solidity
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract StakingPool {
    using SafeERC20 for IERC20;
    
    function stake(uint amount) external {
        // ì•ˆì „í•œ ì „ì†¡
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        
        // SafeERC20ê°€ ì²˜ë¦¬:
        // 1. ë°˜í™˜ê°’ í™•ì¸
        // 2. revert ë³´ì¥
        // 3. approve ì•ˆì „ì„±
    }
}
```

**SafeTransferFrom ë‚´ë¶€:**
```solidity
function safeTransferFrom(IERC20 token, address from, address to, uint value) {
    _callOptionalReturn(
        token,
        abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
    );
}

function _callOptionalReturn(IERC20 token, bytes memory data) private {
    bytes memory returndata = address(token).functionCall(data);
    
    if (returndata.length > 0) {
        // ë°˜í™˜ê°’ì´ ìˆìœ¼ë©´ trueì¸ì§€ í™•ì¸
        require(abi.decode(returndata, (bool)), "SafeERC20: operation failed");
    }
    // ë°˜í™˜ê°’ì´ ì—†ì–´ë„ revert ì•ˆ í–ˆìœ¼ë©´ ì„±ê³µìœ¼ë¡œ ê°„ì£¼
}
```

### 5.3 ì „ì²´ ì ìš©

```solidity
abstract contract CrossStakingBase {
    using SafeERC20 for IERC20;
}

// ëª¨ë“  í† í° ì „ì†¡ì— ì ìš©
stakingToken.safeTransferFrom(from, address(this), amount);
stakingToken.safeTransfer(recipient, amount);
IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
IERC20(token).safeTransfer(user, amount);
IERC20(address(wcross)).safeIncreaseAllowance(stakingPool, amount);
```

---

## 6. Immutable ë³€ìˆ˜ ìµœì í™”

### 6.1 Immutable vs Storage

**ë¹„êµ:**

| íƒ€ì… | ì €ì¥ ìœ„ì¹˜ | ì½ê¸° ë¹„ìš© | ì“°ê¸° ë¹„ìš© |
|-----|---------|----------|----------|
| Storage | ìŠ¤í† ë¦¬ì§€ ìŠ¬ë¡¯ | 2,100 ê°€ìŠ¤ | 20,000 ê°€ìŠ¤ |
| Immutable | ì½”ë“œ ë‚´ | 3 ê°€ìŠ¤ | ë°°í¬ ì‹œ í•œ ë²ˆ |

**ì˜ˆì‹œ:**
```solidity
contract Example {
    // Storage ë³€ìˆ˜
    IERC20 public stakingToken;  // 2,100 ê°€ìŠ¤/ì½ê¸°
    
    // Immutable ë³€ìˆ˜
    IERC20 public immutable stakingToken;  // 3 ê°€ìŠ¤/ì½ê¸°
}
```

### 6.2 í”„ë¡œì íŠ¸ ì ìš©

```solidity
contract StakingPool {
    // ë¶ˆë³€ ê°’ë“¤ì€ immutableë¡œ
    IERC20 public immutable stakingToken;
    uint public immutable projectID;
    IStakingProtocol public immutable protocol;
    
    // ë³€ê²½ ê°€ëŠ¥í•œ ê°’ë“¤ì€ storage
    IRewardPool public rewardPool;
    uint public currentSeason;
    uint public totalStaked;
}

contract RewardPool {
    IStakingPool public immutable stakingPool;
    IStakingProtocol public immutable protocol;
}

contract StakingRouter {
    WCROSS public immutable wcross;
    IStakingProtocol public immutable protocol;
}
```

**íš¨ê³¼:**
```
100ë²ˆì˜ stakingToken ì½ê¸°:
- Storage: 100 Ã— 2,100 = 210,000 ê°€ìŠ¤
- Immutable: 100 Ã— 3 = 300 ê°€ìŠ¤
- ì ˆì•½: 209,700 ê°€ìŠ¤ (700ë°°!)
```

---

## 7. Unchecked ì‚°ìˆ  ìµœì í™”

### 7.1 Solidity 0.8+ ì˜¤ë²„í”Œë¡œìš° ì²´í¬

**ê¸°ë³¸ ë™ì‘:**
```solidity
function increment(uint i) public pure returns (uint) {
    return i + 1;  // ì˜¤ë²„í”Œë¡œìš° ì²´í¬ ì¶”ê°€ (~20 ê°€ìŠ¤)
}

// ì»´íŒŒì¼ëŸ¬ê°€ ìë™ ì‚½ì…:
function increment(uint i) public pure returns (uint) {
    unchecked {
        uint result = i + 1;
        require(result > i, "Overflow");  // ì¶”ê°€ ì½”ë“œ
        return result;
    }
}
```

### 7.2 ì•ˆì „í•œ ê²½ìš° Unchecked ì‚¬ìš©

**ë£¨í”„ ì¹´ìš´í„°:**
```solidity
// ì•ˆì „í•˜ì§€ ì•ŠìŒ (ë¶ˆí•„ìš”í•œ ì²´í¬)
for (uint i = 0; i < 100; i++) {
    // ...
}

// ìµœì í™”
for (uint i = 0; i < 100;) {
    // ...
    unchecked { ++i; }  // ì˜¤ë²„í”Œë¡œìš° ë¶ˆê°€ëŠ¥
}
```

### 7.3 í”„ë¡œì íŠ¸ ì ìš©

```solidity
function _ensureUserAllPreviousSeasons(address user) internal {
    uint startSeason = lastFinalizedSeason[user];
    if (startSeason == 0) startSeason = 1;
    
    for (uint i = startSeason; i < currentSeason;) {
        _ensureUserSeasonSnapshot(user, i);
        unchecked {
            ++i;  // iëŠ” í•­ìƒ currentSeason ë¯¸ë§Œ
        }
    }
}

function claimMultipleRewards(...) external {
    for (uint i = 0; i < seasons.length;) {
        IStakingPool(stakingPool).claimSeason(seasons[i], rewardTokens[i]);
        unchecked {
            ++i;  // ë°°ì—´ ê¸¸ì´ ë‚´ì—ì„œë§Œ ì¦ê°€
        }
    }
}
```

**íš¨ê³¼:**
- ë£¨í”„ë‹¹ ~20 ê°€ìŠ¤ ì ˆì•½
- ê¸´ ë£¨í”„ì—ì„œ í° íš¨ê³¼

---

## 8. Hook íŒ¨í„´ê³¼ í™•ì¥ì„±

### 8.1 Template Method íŒ¨í„´

**ê°œë…:**
```
Base ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì•Œê³ ë¦¬ì¦˜ ê³¨ê²© ì •ì˜
êµ¬ì²´ì ì¸ ë‹¨ê³„ëŠ” í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„
```

**êµ¬í˜„:**

```solidity
abstract contract StakingPoolBase {
    function _stakeFor(address user, uint amount, address from) internal {
        // ê³ ì •ëœ ì•Œê³ ë¦¬ì¦˜
        _ensureSeason();
        
        // Hook 1: ìŠ¤í…Œì´í‚¹ ì „ ì²˜ë¦¬
        _beforeStake(user, amount, oldBalance);
        
        // í•µì‹¬ ë¡œì§
        _performStake(user, amount, from);
        
        // Hook 2: ìŠ¤í…Œì´í‚¹ í›„ ì²˜ë¦¬
        _afterStake(user, amount, newBalance);
    }
    
    // Hook í•¨ìˆ˜ë“¤ (ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥)
    function _beforeStake(address user, uint amount, uint oldBalance) 
        internal virtual {}
    
    function _afterStake(address user, uint amount, uint newBalance) 
        internal virtual {}
}

contract StakingPool is StakingPoolBase {
    // Hook ì˜¤ë²„ë¼ì´ë“œ
    function _afterStake(address user, uint amount, uint newBalance) 
        internal virtual override 
    {
        // Addon ì•Œë¦¼
        if (address(stakingAddon) != address(0)) {
            _callAddonSafe(
                stakingAddon,
                abi.encodeWithSignature(
                    "onStake(address,uint256,uint256,uint256,uint256)",
                    user, amount, oldBalance, newBalance, currentSeason
                )
            );
        }
    }
}
```

### 8.2 í™•ì¥ ì˜ˆì‹œ: ìµœì†Œ ë³´ìœ  ê¸°ê°„

```solidity
contract TimeLockStakingPool is StakingPool {
    mapping(address => uint) public stakingStartTime;
    uint public constant MIN_STAKING_PERIOD = 7 days;
    
    function _afterStake(address user, uint amount, uint newBalance) 
        internal override 
    {
        // ê¸°ì¡´ Hook ì‹¤í–‰
        super._afterStake(user, amount, newBalance);
        
        // ì¶”ê°€ ë¡œì§
        if (stakingStartTime[user] == 0) {
            stakingStartTime[user] = block.timestamp;
        }
    }
    
    function _beforeWithdraw(address user, uint amount) 
        internal override 
    {
        // ë³´ìœ  ê¸°ê°„ í™•ì¸
        require(
            block.timestamp >= stakingStartTime[user] + MIN_STAKING_PERIOD,
            "Minimum staking period not met"
        );
        
        super._beforeWithdraw(user, amount);
    }
}
```

### 8.3 í™•ì¥ ì˜ˆì‹œ: ë³´ë„ˆìŠ¤ ë³´ìƒ

```solidity
contract BonusRewardPool is RewardPool {
    // ì¥ê¸° ë³´ìœ  ë³´ë„ˆìŠ¤: 10%
    uint public constant LONG_TERM_BONUS = 10;  // 10%
    uint public constant LONG_TERM_THRESHOLD = 30 days;
    
    function _calculateBonusReward(
        address user,
        uint season,
        address token,
        uint userPoints,
        uint totalPoints,
        uint baseReward
    ) internal override returns (uint bonusAmount) {
        // ì¥ê¸° ë³´ìœ  ì—¬ë¶€ í™•ì¸
        (,, uint joinBlock,,) = stakingPool.getUserSeasonData(season, user);
        Season memory seasonData = stakingPool.seasons(season);
        
        uint stakingDuration = (seasonData.endBlock - joinBlock) * blockTime;
        
        if (stakingDuration >= LONG_TERM_THRESHOLD) {
            // 10% ë³´ë„ˆìŠ¤
            bonusAmount = baseReward * LONG_TERM_BONUS / 100;
        }
        
        return bonusAmount;
    }
}
```

---

## 9. Addon ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 9.1 ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

```solidity
interface IStakingAddon {
    function onStake(
        address user,
        uint amount,
        uint oldBalance,
        uint newBalance,
        uint season
    ) external;
    
    function onWithdraw(address user, uint amount, uint season) external;
    function onSeasonEnd(uint season, uint totalStaked, uint totalPoints) external;
    function onClaim(address user, uint season, uint points, uint rewardAmount) external;
}
```

### 9.2 ì•ˆì „ í˜¸ì¶œ ë©”ì»¤ë‹ˆì¦˜

**ë¬¸ì œ:**
```solidity
// Addon ì‹¤íŒ¨ ì‹œ ì „ì²´ íŠ¸ëœì­ì…˜ ì‹¤íŒ¨
function _afterStake(...) internal {
    stakingAddon.onStake(...);  // ì—¬ê¸°ì„œ revert â†’ ìŠ¤í…Œì´í‚¹ ì‹¤íŒ¨
}
```

**í•´ê²°:**
```solidity
function _afterStake(...) internal {
    if (address(stakingAddon) != address(0)) {
        _callAddonSafe(stakingAddon, data);  // ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }
}

function _callAddonSafe(IStakingAddon addon, bytes memory data) private {
    try this.callAddon(addon, data) {}
    catch Error(string memory reason) {
        emit AddonCallFailed(addon, bytes4(data), reason);
    }
    catch {
        emit AddonCallFailed(addon, bytes4(data), "Unknown error");
    }
}

// External ë˜í¼ (try/catchë¥¼ ìœ„í•´ í•„ìš”)
function callAddon(IStakingAddon addon, bytes memory data) external {
    require(msg.sender == address(this), "Only self");
    (bool success, bytes memory returnData) = address(addon).call(data);
    if (!success) {
        // revert ì „íŒŒ
        if (returnData.length > 0) {
            assembly {
                revert(add(32, returnData), mload(returnData))
            }
        } else {
            revert("Addon call failed");
        }
    }
}
```

### 9.3 Allowlist ì‹œìŠ¤í…œ

**ë³´ì•ˆ ë¬¸ì œ:**
```solidity
// ë‚˜ìœ ì˜ˆ: ì•„ë¬´ Addonì´ë‚˜ ì„¤ì • ê°€ëŠ¥
function setStakingAddon(IStakingAddon addon) external onlyAdmin {
    stakingAddon = addon;  // ì•…ì˜ì ì¸ ì»¨íŠ¸ë™íŠ¸ ê°€ëŠ¥
}
```

**í•´ê²°:**
```solidity
mapping(address => bool) public approvedAddons;

function setAddonApproved(IStakingAddon addon, bool approved) 
    external onlyRole(DEFAULT_ADMIN_ROLE) 
{
    approvedAddons[address(addon)] = approved;
}

function setStakingAddon(IStakingAddon newAddon) 
    external onlyRole(DEFAULT_ADMIN_ROLE) 
{
    require(
        address(newAddon) == address(0) || 
        approvedAddons[address(newAddon)],
        "Addon not approved"
    );
    stakingAddon = newAddon;
}
```

---

## 10. ê°€ìŠ¤ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

### 10.1 ìŠ¤í† ë¦¬ì§€ ìµœì í™”

- [x] Immutable ë³€ìˆ˜ ì‚¬ìš© (stakingToken, projectID, protocol)
- [x] Packed storage (Season êµ¬ì¡°ì²´)
- [x] Transient storage (ì¬ì§„ì… ë°©ì§€)
- [x] Storage ì½ê¸° ìµœì†Œí™” (ë¡œì»¬ ë³€ìˆ˜ ìºì‹±)

### 10.2 ë£¨í”„ ìµœì í™”

- [x] Unchecked ì¦ê°€ (ë£¨í”„ ì¹´ìš´í„°)
- [x] ë°°ì—´ ê¸¸ì´ ìºì‹±
- [x] Break ì¡°ê±´ ìµœì í™”
- [x] ë¶ˆí•„ìš”í•œ ë£¨í”„ ì œê±° (O(1) ì§‘ê³„)

### 10.3 í•¨ìˆ˜ ìµœì í™”

- [x] External vs Public (external ìš°ì„ )
- [x] View/Pure í•¨ìˆ˜ (ìƒíƒœ ë³€ê²½ ì—†ìŒ)
- [x] Short-circuit evaluation
- [x] ì¡°ê¸° ë°˜í™˜ (early return)

### 10.4 ë°ì´í„° êµ¬ì¡° ìµœì í™”

- [x] Mapping vs Array (ì¡°íšŒ ë¹ˆë²ˆ)
- [x] ì¤‘ì²© ë§¤í•‘ (ë‹¤ì°¨ì› ë°ì´í„°)
- [x] ë¹„íŠ¸ íŒ¨í‚¹ (bool í”Œë˜ê·¸ë“¤)
- [x] ì‚­ì œ í›„ í™˜ë¶ˆ (SSTORE 0)

### 10.5 ì•Œê³ ë¦¬ì¦˜ ìµœì í™”

- [x] O(N) â†’ O(1) (ì‹œì¦Œ ì§‘ê³„)
- [x] ì§€ì—° í‰ê°€ (ìŠ¤ëƒ…ìƒ·)
- [x] ì¦ë¶„ ì—…ë°ì´íŠ¸ (ì§‘ê³„)
- [x] ë°°ì¹˜ ì²˜ë¦¬ (ë‹¤ì¤‘ ì²­êµ¬)

---

## 11. Safe Math ë° ì˜¤ë²„í”Œë¡œìš° ì•ˆì „ì„±

### 11.1 Solidity 0.8+ ë‚´ì¥ ì²´í¬

**ê¸°ë³¸ ë³´í˜¸:**
```solidity
pragma solidity ^0.8.13;

// ìë™ ì˜¤ë²„í”Œë¡œìš° ì²´í¬
uint a = type(uint).max;
uint b = a + 1;  // âŒ Revert (Panic: 0x11)

// ìë™ ì–¸ë”í”Œë¡œìš° ì²´í¬
uint c = 0;
uint d = c - 1;  // âŒ Revert (Panic: 0x11)
```

### 11.2 í¬ì¸íŠ¸ ê³„ì‚° ì•ˆì „ì„± ë¶„ì„

**PointsLib.calculatePoints():**
```solidity
function calculatePoints(...) internal pure returns (uint points) {
    uint blockElapsed = toBlock - fromBlock;
    uint timeElapsed = blockElapsed * blockTime;
    
    // ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ ë¶„ì„:
    // balance * timeElapsed * POINTS_PRECISION
    return (balance * timeElapsed * POINTS_PRECISION) / timeUnit;
}
```

**ì•ˆì „ì„± ì¦ëª…:**
```
ìµœëŒ€ ì—°ì‚°:
- balance: ~10^27 (í† í° ê³µê¸‰ëŸ‰, ì˜ˆ: 10^9 * 10^18)
- timeElapsed: ~10^9 (ìˆ˜ë°±ë§Œ ë¸”ë¡ * ë¸”ë¡ ì‹œê°„)
- POINTS_PRECISION: 10^6

ê³±ì…ˆ ê²°ê³¼: 10^27 * 10^9 * 10^6 = 10^42
uint256 ìµœëŒ€ê°’: ~1.15 * 10^77

ê²°ë¡ : ì•ˆì „ ì—¬ìœ ë„ 10^35ë°° â†’ ì˜¤ë²„í”Œë¡œìš° ë¶ˆê°€ëŠ¥ âœ…
```

**ì£¼ì„ ëª…ì‹œ:**
```solidity
/**
 * @dev Overflow ì•ˆì •ì„±:
 *      - Solidity 0.8+ ë‚´ì¥ ì˜¤ë²„í”Œë¡œìš° ì²´í¬ ì‚¬ìš©
 *      - ìµœëŒ€ ì—°ì‚°: balance(~10^27) * timeElapsed(~10^9) * PRECISION(10^6) = ~10^42
 *      - uint256 ìµœëŒ€ê°’: ~10^77 ì´ë¯€ë¡œ ì•ˆì „í•¨
 *      - ì—°ì‚° ìˆœì„œ: ê³±ì…ˆ ë¨¼ì € ìˆ˜í–‰í•˜ì—¬ ì •ë°€ë„ ìœ ì§€, ë§ˆì§€ë§‰ì— ë‚˜ëˆ—ì…ˆ
 */
```

### 11.3 ë³´ìƒ ë¶„ë°° ì•ˆì „ì„±

**PointsLib.calculateProRata():**
```solidity
function calculateProRata(...) internal pure returns (uint userReward) {
    if (totalAmount == 0 || userAmount == 0) return 0;
    return (rewardAmount * userAmount) / totalAmount;
}
```

**ì•ˆì „ì„± ì¦ëª…:**
```
ì¡°ê±´:
- userAmount â‰¤ totalAmount (ë³´ì¥ë¨)
- rewardAmount * userAmount â‰¤ rewardAmount * totalAmount

ê²°ë¡ : ë¶„ìê°€ ë¶„ëª¨ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìœ¼ë¯€ë¡œ ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ ì—†ìŒ âœ…
```

### 11.4 ì§‘ê³„ ì‹œìŠ¤í…œ ì•ˆì „ì„±

**ì‹œì¦Œ ì§‘ê³„ ì—…ë°ì´íŠ¸:**
```solidity
function _updateSeasonAggregation(uint seasonNum) internal {
    uint additionalPoints = PointsLib.calculatePoints(...);
    
    // ì¦ë¶„ ì—…ë°ì´íŠ¸ (ì˜¤ë²„í”Œë¡œìš° ì²´í¬ ìë™)
    season.aggregatedPoints += additionalPoints;  // âœ… 0.8+ ìë™ ì²´í¬
    season.lastAggregatedBlock = block.number;
}
```

**ë³´í˜¸ ë©”ì»¤ë‹ˆì¦˜:**
1. Solidity 0.8+ ìë™ ì²´í¬
2. í˜„ì‹¤ì  ë²”ìœ„ ë‚´ ì—°ì‚°
3. ì¦ë¶„ ì—…ë°ì´íŠ¸ (ëˆ„ì ì€ í•œì •ì )

### 11.5 ì–¸ì œ Uncheckedë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?

**ì•ˆì „í•œ Unchecked ì‚¬ìš©:**
```solidity
// âœ… ë£¨í”„ ì¹´ìš´í„° (ë²”ìœ„ ì œí•œë¨)
unchecked {
    ++i;
}

// âœ… ì´ë¯¸ ê²€ì¦ëœ ê°’
if (a > b) {
    unchecked {
        uint diff = a - b;  // ì•ˆì „í•¨
    }
}
```

**ì ˆëŒ€ í•˜ì§€ ë§ì•„ì•¼ í•  ê²ƒ:**
```solidity
// âŒ ì‚¬ìš©ì ì…ë ¥
unchecked {
    uint result = userInput1 * userInput2;  // ìœ„í—˜!
}

// âŒ í† í° ì”ì•¡
unchecked {
    balance += amount;  // ìœ„í—˜!
}
```

### 11.6 ì •ë°€ë„ vs ì˜¤ë²„í”Œë¡œìš° íŠ¸ë ˆì´ë“œì˜¤í”„

**í˜„ì¬ ì„ íƒ:**
```solidity
POINTS_PRECISION = 1e6  // ì†Œìˆ˜ì  6ìë¦¬
```

**ì´ìœ :**
- ì¶©ë¶„í•œ ì •ë°€ë„ (0.000001 ë‹¨ìœ„)
- ì˜¤ë²„í”Œë¡œìš° ì•ˆì „ ì—¬ìœ ë„ ì¶©ë¶„
- ê°€ìŠ¤ íš¨ìœ¨ì 

**ëŒ€ì•ˆ ê²€í† :**
```
1e18 (ë†’ì€ ì •ë°€ë„):
- ì¥ì : ë§¤ìš° ì •ë°€
- ë‹¨ì : ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ ì¦ê°€ (ì—¬ìœ ë„ 10^17ë°° ê°ì†Œ)

1e3 (ë‚®ì€ ì •ë°€ë„):
- ì¥ì : ì˜¤ë²„í”Œë¡œìš° ë§¤ìš° ì•ˆì „
- ë‹¨ì : ì •ë°€ë„ ë¶€ì¡± (0.001 ë‹¨ìœ„)

ê²°ë¡ : 1e6ì´ ìµœì  âœ…
```

### 11.7 ìš”ì•½

**ì•ˆì „ì„± ê³„ì¸µ:**
1. âœ… Solidity 0.8+ ìë™ ì˜¤ë²„í”Œë¡œìš° ì²´í¬
2. âœ… í˜„ì‹¤ì  ë²”ìœ„ ë‚´ ì—°ì‚° ì„¤ê³„
3. âœ… ëª…ì‹œì  ì•ˆì „ì„± ì£¼ì„
4. âœ… ê²€ì¦ëœ ìˆ˜í•™ì  ì¦ëª…
5. âœ… ì „ì²´ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€

**ê²°ë¡ :** Cross Stakingì€ ì˜¤ë²„í”Œë¡œìš°ë¡œë¶€í„° ì™„ì „íˆ ì•ˆì „í•©ë‹ˆë‹¤. ğŸ›¡ï¸

---

## ìš”ì•½

Cross Staking í”„ë¡œì íŠ¸ëŠ” ë‹¤ìŒ ê¸°ìˆ ë“¤ì„ í™œìš©í•˜ì—¬ í™•ì¥ ê°€ëŠ¥í•˜ê³  ê°€ìŠ¤ íš¨ìœ¨ì ì¸ ìŠ¤í…Œì´í‚¹ í”Œë«í¼ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤:

1. **Code íŒ¨í„´**: ì»¨íŠ¸ë™íŠ¸ í¬ê¸° ì œí•œ ê·¹ë³µ
2. **O(1) ì§‘ê³„**: ì‹œì¦Œ ì´ í¬ì¸íŠ¸ ê³„ì‚° ìµœì í™”
3. **ì§€ì—° ìŠ¤ëƒ…ìƒ·**: ì‹œì¦Œ ì „í™˜ ê°€ìŠ¤ ë¹„ìš© ìµœì†Œí™”
4. **Transient Storage**: ì¬ì§„ì… ë°©ì§€ ê°€ìŠ¤ ì ˆì•½
5. **SafeERC20**: í† í° ì•ˆì „ì„± ë³´ì¥
6. **Immutable**: ë³€ìˆ˜ ì½ê¸° ë¹„ìš© ìµœì†Œí™”
7. **Unchecked**: ì•ˆì „í•œ ì‚°ìˆ  ìµœì í™”
8. **Hook íŒ¨í„´**: í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜
9. **Addon ì‹œìŠ¤í…œ**: ë…ë¦½ì ì¸ ê¸°ëŠ¥ ì¶”ê°€
10. **ì¢…í•© ìµœì í™”**: ë‹¤ì¸µ ê°€ìŠ¤ ìµœì í™”
11. **Safe Math**: ì˜¤ë²„í”Œë¡œìš° ì™„ì „ ë°©ì§€

ì´ëŸ¬í•œ ê¸°ìˆ ë“¤ì˜ ì¡°í•©ìœ¼ë¡œ ìˆ˜ì²œ ëª…ì˜ ìŠ¤í…Œì´ì»¤ë¥¼ ì§€ì›í•˜ë©´ì„œë„ í•©ë¦¬ì ì¸ ê°€ìŠ¤ ë¹„ìš©ì„ ìœ ì§€í•©ë‹ˆë‹¤.

