# 컨트랙트 상세 설명

## StakingProtocol

### 개요

StakingProtocol은 **프로젝트 팩토리**로서 프로젝트별 StakingPool과 RewardPool을 생성하고 관리합니다.

### 주요 상태 변수

```solidity
// 토큰
IERC20 private immutable _crossToken;  // $CROSS 토큰

// Code 컨트랙트 (creation code 제공)
address public immutable stakingPoolCodeContract;
address public immutable rewardPoolCodeContract;

// 프로젝트 관리
mapping(uint => ProjectInfo) public projects;
uint public projectCount;
mapping(string => uint) public projectIDByName;
mapping(address => uint[]) public projectsByAddress;

// 설정
uint public defaultSeasonBlocks = 2592000;  // 약 30일
```

### 핵심 함수

#### createProject()

**시그니처:**
```solidity
function createProject(
    string calldata projectName,
    uint seasonBlocks,
    uint firstSeasonStartBlock,
    uint poolEndBlock,
    address projectAdmin
) external nonReentrant 
  returns (uint projectID, address stakingPool, address rewardPool)
```

**파라미터:**
- `projectName`: 프로젝트 이름 (고유해야 함)
- `seasonBlocks`: 시즌 길이 (0이면 기본값 사용)
- `firstSeasonStartBlock`: 첫 시즌 시작 블록
- `poolEndBlock`: 풀 종료 블록 (0이면 무한)
- `projectAdmin`: 프로젝트 관리자 주소 (0이면 msg.sender)

**동작:**
1. 프로젝트 이름 중복 확인
2. projectCount 증가
3. StakingPool 배포 (Code 패턴 + **CREATE2**)
   - salt = `keccak256(projectName, projectID, "StakingPool")`
   - 주소 예측 가능
4. RewardPool 배포 (Code 패턴 + **CREATE2**)
   - salt = `keccak256(projectName, projectID, "RewardPool")`
   - 주소 예측 가능
5. 풀 간 연결 설정
6. ProjectInfo 저장

**CREATE2 특징:**
- 배포 전 주소 미리 계산 가능 (`computeStakingPoolAddress`, `computeRewardPoolAddress`)
- 프로젝트 이름으로 deterministic address 생성 (projectID는 salt에 포함되지 않음)
- 크로스체인 배포 시 동일 프로젝트 이름을 사용하면 동일 주소 보장 가능

**CREATE2 Salt 구성 의도:**
- Salt = `keccak256(abi.encode(projectName, "StakingPool"))` 또는 `keccak256(abi.encode(projectName, "RewardPool"))`
- projectID를 salt에 포함하지 않는 이유:
  1. **크로스체인 결정성**: 동일한 프로젝트 이름을 사용하면 다른 체인에서도 동일한 주소로 배포 가능
  2. **주소 예측 가능성**: 프로젝트 생성 전에도 프로젝트 이름만으로 주소 계산 가능
  3. **동일 체인 충돌 방지**: `projectIDByName` 매핑으로 프로젝트 이름 중복 방지
- 이는 의도된 설계이며, 동일 체인에서 이름 충돌은 `createProject()`에서 검증됨

**예시:**
```solidity
// 30일 시즌, 100만 블록 후 시작, 종료 블록 없음, admin은 호출자
(uint projectID, address pool, address reward) = 
    protocol.createProject(
        "My Project",
        0,  // 기본값 사용
        block.number + 1_000_000,
        0,  // 무한
        address(0)  // msg.sender가 admin으로 설정됨
    );

// 특정 주소를 admin으로 설정
(uint projectID2, address pool2, address reward2) = 
    protocol.createProject(
        "My Project 2",
        0,
        block.number,
        0,
        0x1234567890123456789012345678901234567890  // 명시적 admin
    );
```

**Code 패턴 구현:**
```solidity
function _deployStakingPool(...) internal returns (address pool) {
    // Code 컨트랙트에서 creation code 가져오기
    bytes memory code = _getStakingPoolCode();
    
    // Constructor 인자와 결합
    bytes memory bytecode = bytes.concat(
        code,
        abi.encode(projectID, address(_crossToken), ...)
    );
    
    // 어셈블리로 배포
    assembly {
        pool := create(0, add(bytecode, 0x20), mload(bytecode))
    }
    
    require(pool != address(0), "Deployment failed");
}
```

#### fundProjectSeason()

**시그니처:**
```solidity
function fundProjectSeason(
    uint projectID,
    uint season,
    address token,
    uint amount
) external nonReentrant
```

**권한:** 프로젝트 creator 또는 admin만 호출 가능

**동작:**
1. 프로젝트 ID 검증
2. msg.sender가 creator 또는 admin인지 확인
3. 프로젝트 활성 상태 확인
4. RewardPool.fundSeason() 호출

**예시:**
```solidity
// 프로젝트 1의 시즌 2에 1000 토큰 예치
token.approve(protocol, 1000);
protocol.fundProjectSeason(1, 2, address(token), 1000);
```

#### ProjectInfo 구조체

```solidity
struct ProjectInfo {
    address stakingPool;    // StakingPool 주소
    address rewardPool;     // RewardPool 주소
    string name;            // 프로젝트 이름
    bool isActive;          // 활성 상태
    uint createdAt;         // 생성 시간
    address creator;        // 생성자 주소
    address admin;          // 프로젝트 관리자 (pool 설정 변경 가능)
}
```

**권한 구조:**
- **creator**: 프로젝트를 생성한 주소 (변경 불가)
- **admin**: 프로젝트 풀 설정을 변경할 수 있는 관리자 (변경 가능)
- **Protocol Admin**: 프로토콜 전체 관리자 (모든 권한)

#### 관리 함수들

**setProjectAdmin():**
```solidity
function setProjectAdmin(uint projectID, address newAdmin) external
```
- **권한**: 현재 project admin만 호출 가능
- **동작**: 프로젝트 admin을 새 주소로 변경
- **보안**: admin 권한 이전 시 신중히 사용

**setProjectStatus():**
```solidity
function setProjectStatus(uint projectID, bool isActive) 
    external onlyRole(DEFAULT_ADMIN_ROLE)
```
- **권한**: 프로토콜 admin만 호출 가능
- **동작**: 프로젝트 활성화/비활성화

**setApprovedRouter():**
```solidity
function setApprovedRouter(uint projectID, address router, bool approved)
    external // project admin 또는 protocol admin
```
- **권한**: project admin 또는 protocol admin
- **동작**: Router에게 ROUTER_ROLE 부여/제거

**Pool 설정 함수들 (project admin 또는 protocol admin):**
```solidity
setPoolPointsTimeUnit(uint projectID, uint timeUnit)  // 포인트 시간 단위
setPoolBlockTime(uint projectID, uint blockTime)      // 블록 시간
setPoolNextSeasonStart(uint projectID, uint startBlock) // 다음 시즌 시작
setPoolEndBlock(uint projectID, uint endBlock)        // 풀 종료 블록
setPoolStakingAddon(uint projectID, IStakingAddon addon) // Addon 설정
setPoolAddonApproved(uint projectID, IStakingAddon addon, bool approved) // Addon 승인
```

**프로토콜 전역 설정 (protocol admin 전용):**
```solidity
setDefaultSeasonBlocks(uint blocks)        // 기본 시즌 길이
setPoolRewardPool(uint projectID, IRewardPool pool)   // RewardPool 변경 (보안상 제한적)
```

#### 조회 함수들

**getProject():**
```solidity
function getProject(uint projectID) 
    external view 
    returns (ProjectInfo memory)
```

**getProjectsByCreator():**
```solidity
function getProjectsByCreator(address creator) 
    external view 
    returns (uint[] memory)
```

**getProjects():**
```solidity
function getProjects(uint offset, uint limit)
    external view
    returns (ProjectInfo[] memory projectList, uint total)
```
페이지네이션 지원

**computeStakingPoolAddress():** (CREATE2 주소 계산)
```solidity
function computeStakingPoolAddress(
    string calldata projectName,
    uint projectID,
    uint seasonBlocks,
    uint firstSeasonStartBlock,
    uint poolEndBlock
) external view returns (address)
```
배포 전 StakingPool 주소를 미리 계산합니다.

**사용 예시:**
```solidity
// 프로젝트 생성 전 주소 미리 확인
uint nextProjectID = protocol.projectCount() + 1;
address predictedStakingPool = protocol.computeStakingPoolAddress(
    "My Project",
    nextProjectID,
    86400,  // 1일
    block.number + 100,
    0
);

// 실제 생성
(uint projectID, address stakingPool, ) = protocol.createProject(...);

// 주소 일치 확인
assert(stakingPool == predictedStakingPool);
```

**computeRewardPoolAddress():** (CREATE2 주소 계산)
```solidity
function computeRewardPoolAddress(
    string calldata projectName,
    uint projectID,
    address stakingPool
) external view returns (address)
```
배포 전 RewardPool 주소를 미리 계산합니다.

**주의사항:**
- StakingPool 주소를 먼저 계산한 후 RewardPool 주소를 계산해야 합니다.
- 생성자 파라미터가 변경되면 주소도 달라집니다.

---

## StakingPool

### 개요

StakingPool은 **개별 프로젝트의 스테이킹 관리**를 담당합니다. 토큰 스테이킹, 포인트 계산, 시즌 관리, 보상 청구를 처리합니다.

### 주요 상태 변수

```solidity
// 불변 변수
IERC20 public immutable stakingToken;     // $CROSS (WCROSS)
uint public immutable projectID;
IStakingProtocol public immutable protocol;

// 연결
IRewardPool public rewardPool;
IStakingAddon public stakingAddon;

// 사용자 데이터
mapping(address => StakePosition) public userStakes;
mapping(uint => mapping(address => UserSeasonData)) public userSeasonData;

// 시즌 데이터
uint public currentSeason;
mapping(uint => Season) public seasons;

// 설정
uint public seasonBlocks;
uint public poolEndBlock;
uint public nextSeasonStartBlock;
uint public pointsTimeUnit = 1 hours;
uint public blockTime = 1;

// 전역 상태
uint public totalStaked;
address[] public stakers;
```

### 핵심 함수

#### stake()

**시그니처:**
```solidity
function stake(uint amount) external nonReentrant
```

**동작:**
1. `_ensureSeason()` 호출 (시즌 자동 전환)
2. 시즌 활성 확인
3. 이전 시즌 데이터 처리
4. 포인트 계산 및 업데이트
5. 최소 스테이킹 확인 (1 CROSS)
6. 토큰 전송 (SafeERC20)
7. 집계 업데이트
8. Addon 알림

**포인트 계산 로직:**
```solidity
// 기존 스테이킹이 있으면 포인트 계산
if (oldBalance > 0) {
    uint startBlock = position.lastUpdateBlock < season.startBlock 
        ? season.startBlock 
        : position.lastUpdateBlock;
    
    uint additionalPoints = PointsLib.calculatePoints(
        position.balance,
        startBlock,
        block.number,
        blockTime,
        pointsTimeUnit
    );
    
    userSeasonData[currentSeason][user].points += additionalPoints;
}
```

**예시:**
```solidity
// WCROSS approve 필요
IERC20(wcross).approve(stakingPool, 100 ether);
stakingPool.stake(100 ether);
```

#### stakeFor()

**시그니처:**
```solidity
function stakeFor(address user, uint amount) 
    external nonReentrant onlyRole(ROUTER_ROLE)
```

**권한:** ROUTER_ROLE만 호출 가능

**용도:**
- StakingRouter가 사용자를 대신해 스테이킹
- Native CROSS 스테이킹 구현

**동작:**
- `_stakeFor(user, amount, msg.sender)` 호출
- msg.sender(Router)로부터 토큰 전송
- user에게 스테이킹 기록

#### withdrawAll()

**시그니처:**
```solidity
function withdrawAll() external nonReentrant
```

**동작:**
1. `_ensureSeason()` 호출
2. 이전 시즌 데이터 처리
3. 잔액 확인
4. 현재 시즌 데이터 초기화
5. 집계 업데이트
6. 토큰 전송 (SafeERC20)
7. Addon 알림

**주의사항:**
- 전액 출금만 가능 (부분 출금 불가)
- 현재 시즌 포인트는 소멸
- 이전 시즌 보상은 청구 가능

#### withdrawAllFor()

**시그니처:**
```solidity
function withdrawAllFor(address user) 
    external nonReentrant onlyRole(ROUTER_ROLE)
```

**권한:** ROUTER_ROLE만 호출 가능

**용도:**
- StakingRouter가 사용자를 대신해 출금
- Native CROSS로 자동 변환

#### rolloverSeason()

**시그니처:**
```solidity
function rolloverSeason() external
```

**동작:**
1. 현재 시즌 확인
2. 종료 블록 도달 확인
3. `_rolloverSeason()` 호출

**자동 호출:**
- 실제로는 `_ensureSeason()`이 자동으로 처리
- 수동 호출도 가능 (가스 최적화)

#### claimSeason()

**시그니처:**
```solidity
function claimSeason(uint seasonNumber, address rewardToken) 
    external nonReentrant
```

**동작:**
1. 시즌 finalized 확인
2. 유저 시즌 스냅샷 생성
3. 중복 청구 확인
4. 포인트 조회
5. 총 포인트 계산 (필요 시)
6. RewardPool.payUser() 호출

**예시:**
```solidity
// 시즌 1의 token1 보상 청구
stakingPool.claimSeason(1, address(token1));

// 시즌 1의 token2 보상 청구
stakingPool.claimSeason(1, address(token2));
```

#### updatePoints()

**시그니처:**
```solidity
function updatePoints(address user) external
```

**권한:** REWARD_POOL_ROLE 또는 DEFAULT_ADMIN_ROLE

**용도:**
- 사용자 포인트를 현재 블록 기준으로 업데이트
- 정확한 포인트 조회를 위해 사용

### 조회 함수들

#### getStakePosition()

**시그니처:**
```solidity
function getStakePosition(address user) 
    external view 
    returns (uint balance, uint points, uint lastUpdateBlock)
```

**반환값:**
- `balance`: 현재 스테이킹 잔액
- `points`: 현재 시즌 누적 포인트 (실시간 계산)
- `lastUpdateBlock`: 마지막 업데이트 블록

#### getCurrentSeasonInfo()

**시그니처:**
```solidity
function getCurrentSeasonInfo() external view
    returns (uint season, uint startBlock, uint endBlock, uint blocksElapsed)
```

**특징:**
- 가상 시즌도 처리 (nextSeasonStartBlock 설정 시)
- 현재 시즌이 없으면 (0, 0, 0, 0) 반환

#### getUserPoints()

**시그니처:**
```solidity
function getUserPoints(address user) public view returns (uint)
```

**동작:**
- `_calculateCurrentSeasonPoints()` 호출
- 실시간 포인트 계산 (상태 변경 없음)
- 가상 시즌도 고려

#### getSeasonUserPoints()

**시그니처:**
```solidity
function getSeasonUserPoints(uint seasonNumber, address user) 
    external view returns (uint)
```

**동작:**
1. UserSeasonData 확인
2. finalized면 저장된 포인트 반환
3. 아니면 계산하여 반환

#### seasonTotalPointsSnapshot()

**시그니처:**
```solidity
function seasonTotalPointsSnapshot(uint seasonNumber) 
    external view returns (uint)
```

**동작:**
- Finalized 시즌: totalPoints 반환
- 현재 시즌: 집계 포인트 + 증분 포인트
- 미래/과거 시즌: 0

#### getExpectedSeasonPoints()

**시그니처:**
```solidity
function getExpectedSeasonPoints(uint seasonNumber, address user)
    external view returns (uint)
```

**용도:**
- 시즌별 예상 포인트 조회
- 보상 계산 전 확인

#### getExpectedSeasonReward()

**시그니처:**
```solidity
function getExpectedSeasonReward(
    uint seasonNumber,
    address user,
    address rewardToken
) external view returns (uint)
```

**동작:**
1. RewardPool 연결 확인
2. 시즌 finalized 확인
3. 유저 포인트 조회
4. 총 포인트 조회
5. RewardPool.getExpectedReward() 호출

#### previewClaim()

**시그니처:**
```solidity
function previewClaim(
    uint seasonNumber,
    address user,
    address rewardToken
) external view returns (
    uint userPoints,
    uint totalPoints,
    uint expectedReward,
    bool alreadyClaimed,
    bool canClaim
)
```

**용도:**
- 청구 전 미리보기
- UI에서 사용자에게 정보 표시

#### getUserSeasonData()

**시그니처:**
```solidity
function getUserSeasonData(uint seasonNumber, address user)
    external view
    returns (
        uint points,
        uint balance,
        uint joinBlock,
        bool claimed,
        bool finalized
    )
```

**용도:**
- 시즌별 사용자 상세 데이터 조회

#### getStakers()

**시그니처:**
```solidity
function getStakers(uint offset, uint limit)
    external view
    returns (address[] memory stakerList, uint total)
```

**용도:**
- 스테이커 목록 페이지네이션 조회

**Stakers 배열 관리 전략:**
- 스테이커가 `stake()`를 호출하면 `stakers` 배열에 추가됨
- `isStaker` 매핑은 true로 설정되고 이후 변경되지 않음
- **잔액이 0이 되어도** 사용자는 배열에서 제거되지 않음 (설계상 의도)
- **장점**: 가스 효율성 (배열 재정렬 불필요), 히스토리 보존
- **단점**: 배열 크기가 계속 증가할 수 있음
- **권장 사항**:
  1. 프론트엔드/백엔드에서 `getStakers()`를 페이지네이션으로 호출
  2. 반환된 주소 중 `getStakePosition(user).balance > 0`인 사용자만 필터링
  3. 오프체인에서 활성 스테이커 목록 관리
- **향후 개선 (선택)**: 별도 GC(garbage collection) 함수를 도입하여 관리자가 수동으로 0 balance 사용자를 정리할 수 있도록 구현 가능

#### finalizeUserSeasonsBatch()

**시그니처:**
```solidity
function finalizeUserSeasonsBatch(address user, uint maxSeasons)
    external
    returns (uint processed)
```

**용도:**
- 여러 시즌을 한 번에 처리
- 가스 한도 내에서 최대한 처리

**예시:**
```solidity
// 최대 5개 시즌 처리
uint processed = stakingPool.finalizeUserSeasonsBatch(user, 5);
```

### 설정 함수들

#### setRewardPool()

**시그니처:**
```solidity
function setRewardPool(IRewardPool _rewardPool) 
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**제약:**
- 한 번만 설정 가능 (이미 설정되면 revert)
- REWARD_POOL_ROLE 자동 부여

#### setApprovedRouter()

**시그니처:**
```solidity
function setApprovedRouter(address router, bool approved)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**동작:**
- approved=true: ROUTER_ROLE 부여
- approved=false: ROUTER_ROLE 제거

#### setPointsTimeUnit()

**시그니처:**
```solidity
function setPointsTimeUnit(uint _timeUnit)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**효과:**
- 포인트 계산 시간 단위 변경
- 이후 계산에만 영향

#### setBlockTime()

**시그니처:**
```solidity
function setBlockTime(uint _blockTime)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**효과:**
- 블록 시간 변경 (초 단위)
- 네트워크 블록 시간에 맞춤

#### setNextSeasonStart()

**시그니처:**
```solidity
function setNextSeasonStart(uint _startBlock)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**용도:**
- 다음 시즌 시작 블록 수동 설정
- 시즌 간격 조정

#### setPoolEndBlock()

**시그니처:**
```solidity
function setPoolEndBlock(uint _endBlock)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**용도:**
- 풀 종료 블록 설정/변경
- 0으로 설정 시 무한

#### setStakingAddon()

**시그니처:**
```solidity
function setStakingAddon(IStakingAddon newAddon)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**제약:**
- 승인된 Addon만 설정 가능 (approvedAddons)
- address(0)으로 제거 가능

#### setAddonApproved()

**시그니처:**
```solidity
function setAddonApproved(IStakingAddon addon, bool approved)
    external onlyRole(DEFAULT_ADMIN_ROLE)
```

**용도:**
- Addon allowlist 관리
- 보안을 위해 승인 시스템 사용

---

## RewardPool

### 개요

RewardPool은 **시즌별 보상 관리**를 담당합니다. 보상 예치, 보상 분배, 청구 기록을 처리합니다.

### 주요 상태 변수

```solidity
// 불변 변수
IStakingPool public immutable stakingPool;
IStakingProtocol public immutable protocol;

// 보상 데이터
mapping(uint => mapping(address => uint)) public seasonRewards;
mapping(uint => mapping(address => uint)) public seasonClaimed;
mapping(address => mapping(uint => mapping(address => bool))) 
    public hasClaimedSeasonReward;
```

### 핵심 함수

#### fundSeason()

**시그니처:**
```solidity
function fundSeason(uint season, address token, uint amount)
    external nonReentrant
```

**동작:**
1. 입력 검증
2. 토큰 전송 (SafeERC20)
3. seasonRewards에 누적
4. SeasonFunded 이벤트 발생

**특징:**
- 누구나 호출 가능 (예치 제한 없음)
- 여러 번 예치 가능 (누적)
- 미래 시즌에도 미리 예치 가능

**예시:**
```solidity
// 시즌 3에 1000 토큰 예치
token.approve(rewardPool, 1000);
rewardPool.fundSeason(3, address(token), 1000);

// 동일 시즌에 추가 예치
rewardPool.fundSeason(3, address(token), 500);
// 총 1500 토큰
```

#### payUser()

**시그니처:**
```solidity
function payUser(
    address user,
    uint season,
    address token,
    uint userPoints,
    uint totalPoints
) external onlyRole(STAKING_POOL_ROLE) nonReentrant
```

**권한:** STAKING_POOL_ROLE만 호출 (StakingPool에서만)

**동작:**
1. 중복 청구 확인
2. 포인트 검증
3. 기본 보상 계산 (비례 분배)
4. 보너스 보상 계산 (Hook)
5. 잔액 확인
6. 청구 기록
7. 토큰 전송 (SafeERC20)
8. RewardPaid 이벤트

**보상 계산:**
```solidity
uint totalReward = seasonRewards[season][token];
uint baseReward = PointsLib.calculateProRata(
    userPoints,
    totalPoints,
    totalReward
);

// 보너스 계산 (기본 구현은 0)
uint bonusReward = _calculateBonusReward(...);

uint totalPayout = baseReward + bonusReward;
```

#### depositReward()

**시그니처:**
```solidity
function depositReward(address token, uint amount) external nonReentrant
```

**용도:**
- 현재 시즌에 보상 예치 (간편 함수)
- fundSeason()의 래퍼

**동작:**
```solidity
uint currentSeason = stakingPool.currentSeason();
IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
seasonRewards[currentSeason][token] += amount;
```

### 조회 함수들

#### getExpectedReward()

**시그니처:**
```solidity
function getExpectedReward(address user, uint season, address token)
    external view returns (uint expectedReward)
```

**동작:**
1. 청구 여부 확인
2. StakingPool에서 포인트 조회
3. 비례 계산

**예시:**
```solidity
uint reward = rewardPool.getExpectedReward(alice, 1, address(token));
```

#### getRemainingRewards()

**시그니처:**
```solidity
function getRemainingRewards(uint season, address token)
    external view returns (uint)
```

**반환:**
```solidity
return seasonRewards[season][token] - seasonClaimed[season][token];
```

#### getUserPendingReward()

**시그니처:**
```solidity
function getUserPendingReward(address user, address token)
    external view returns (uint)
```

**용도:**
- 현재 시즌의 예상 보상 조회
- getExpectedReward()의 래퍼

#### getSeasonSummary()

**시그니처:**
```solidity
function getSeasonSummary(uint season, address[] calldata tokens)
    external view
    returns (
        uint[] memory totals,
        uint[] memory claimed,
        uint[] memory remaining
    )
```

**용도:**
- 여러 토큰의 시즌 보상 정보 일괄 조회

#### getUserClaimed()

**시그니처:**
```solidity
function getUserClaimed(address user, uint season, address token)
    external view returns (bool)
```

**반환:**
```solidity
return hasClaimedSeasonReward[user][season][token];
```

### 관리 함수

#### sweep()

**시그니처:**
```solidity
function sweep(address token, address to, uint amount) external
```

**권한:** protocol 주소만 호출 가능

**용도:**
- 잘못 전송된 토큰 회수
- 잔여 토큰 회수

**예시:**
```solidity
// Protocol 컨트랙트에서 호출
rewardPool.sweep(address(token), treasury, amount);
```

---

## StakingRouter

### 개요

StakingRouter는 **사용자 친화적 인터페이스**를 제공합니다. Native CROSS를 사용하여 스테이킹하고, 다양한 편의 함수를 제공합니다.

### 주요 상태 변수

```solidity
WCROSS public immutable wcross;
IStakingProtocol public immutable protocol;
```

### 핵심 함수

#### stake()

**시그니처:**
```solidity
function stake(uint projectID) external payable nonReentrant
```

**동작:**
1. msg.value 검증
2. 프로젝트 ID 검증
3. Native CROSS → WCROSS 변환
4. WCROSS approve
5. StakingPool.stakeFor() 호출

**예시:**
```solidity
// 100 Native CROSS 스테이킹
router.stake{value: 100 ether}(projectID);
```

#### unstake()

**시그니처:**
```solidity
function unstake(uint projectID) external nonReentrant
```

**동작:**
1. 프로젝트 ID 검증
2. StakingPool.withdrawAllFor() 호출
3. Router가 WCROSS 수령
4. WCROSS → Native CROSS 변환
5. Native CROSS 전송

**예시:**
```solidity
// 전액 출금 (Native CROSS로 반환)
router.unstake(projectID);
```

#### claimReward()

**시그니처:**
```solidity
function claimReward(uint projectID, uint season, address rewardToken)
    external nonReentrant
```

**동작:**
- StakingPool.claimSeason() 호출

#### claimMultipleRewards()

**시그니처:**
```solidity
function claimMultipleRewards(
    uint projectID,
    uint[] calldata seasons,
    address[] calldata rewardTokens
) external nonReentrant
```

**용도:**
- 여러 시즌 보상을 한 번에 청구
- 가스 효율적

**예시:**
```solidity
uint[] memory seasons = new uint[](3);
seasons[0] = 1;
seasons[1] = 2;
seasons[2] = 3;

address[] memory tokens = new address[](3);
tokens[0] = address(token1);
tokens[1] = address(token1);
tokens[2] = address(token2);

router.claimMultipleRewards(projectID, seasons, tokens);
```

#### finalizeUserSeasonsBatch()

**시그니처:**
```solidity
function finalizeUserSeasonsBatch(
    uint projectID,
    address user,
    uint maxSeasons
) external returns (uint processed)
```

**용도:**
- StakingPool의 배치 처리 함수 호출
- 여러 시즌 데이터를 한 번에 처리

### 조회 함수들 (일부)

#### getStakeInfo()

**시그니처:**
```solidity
function getStakeInfo(uint projectID, address user)
    external view
    returns (uint balance, uint points, uint lastUpdateBlock)
```

#### getSeasonInfo()

**시그니처:**
```solidity
function getSeasonInfo(uint projectID)
    external view
    returns (
        uint currentSeason,
        uint seasonStartBlock,
        uint seasonEndBlock,
        uint blocksRemaining
    )
```

#### getClaimableReward()

**시그니처:**
```solidity
function getClaimableReward(
    uint projectID,
    address user,
    uint season,
    address rewardToken
) external view returns (uint claimableAmount)
```

#### getUserStakingSummary()

**시그니처:**
```solidity
function getUserStakingSummary(address user, uint[] calldata projectIDs)
    external view
    returns (
        uint[] memory balances,
        uint[] memory points,
        uint[] memory currentSeasons
    )
```

**용도:**
- 여러 프로젝트의 스테이킹 정보를 한 번에 조회
- UI에서 대시보드 표시

#### getActiveProjects()

**시그니처:**
```solidity
function getActiveProjects(uint offset, uint limit)
    external view
    returns (
        uint[] memory projectIDs,
        address[] memory stakingPools,
        string[] memory names
    )
```

**용도:**
- 활성 프로젝트 목록 조회 (페이지네이션)

#### previewClaim()

**시그니처:**
```solidity
function previewClaim(
    uint projectID,
    address user,
    uint season,
    address rewardToken
) external view returns (
    uint expectedReward,
    uint userPoints,
    uint totalPoints,
    bool alreadyClaimed
)
```

**용도:**
- StakingPool의 previewClaim 호출
- 청구 전 미리보기

---

## WCROSS

### 개요

WCROSS는 **Native CROSS를 ERC20으로 래핑**하는 컨트랙트입니다.

### 주요 함수

#### deposit()

**시그니처:**
```solidity
function deposit() external payable
```

**동작:**
```solidity
balanceOf[msg.sender] += msg.value;
totalSupply += msg.value;
emit Deposit(msg.sender, msg.value);
```

**예시:**
```solidity
wcross.deposit{value: 100 ether}();
```

#### withdraw()

**시그니처:**
```solidity
function withdraw(uint amount) external
```

**동작:**
```solidity
require(balanceOf[msg.sender] >= amount);

balanceOf[msg.sender] -= amount;
totalSupply -= amount;

(bool success,) = msg.sender.call{value: amount}("");
require(success, "Transfer failed");

emit Withdrawal(msg.sender, amount);
```

#### ERC20 함수들

**transfer():**
```solidity
function transfer(address to, uint amount) external returns (bool)
```

**transferFrom():**
```solidity
function transferFrom(address from, address to, uint amount)
    public returns (bool)
```

**approve():**
```solidity
function approve(address spender, uint amount) external returns (bool)
```

### 특별 함수

#### receive()

```solidity
receive() external payable {
    balanceOf[msg.sender] += msg.value;
    totalSupply += msg.value;
    emit Deposit(msg.sender, msg.value);
}
```

**용도:**
- Native CROSS를 전송하면 자동으로 deposit

**예시:**
```solidity
// 이렇게 전송하면 자동 deposit
(bool success,) = address(wcross).call{value: 100 ether}("");
```

---

## RankingAddon

### 개요

RankingAddon은 **스테이킹 랭킹 집계 예제**입니다. IStakingAddon 인터페이스를 구현합니다.

### 주요 상태 변수

```solidity
address public immutable stakingPool;

mapping(uint => mapping(address => uint)) public rankingScores;
mapping(uint => address[]) public topStakers;
mapping(uint => mapping(address => bool)) private isTopStaker;

uint public constant MAX_TOP_STAKERS = 100;
```

### 콜백 함수들

#### onStake()

**시그니처:**
```solidity
function onStake(
    address user,
    uint amount,
    uint oldBalance,
    uint newBalance,
    uint season
) external onlyPool
```

**동작:**
1. 랭킹 점수 업데이트 (newBalance 기준)
2. Top 스테이커 목록 업데이트

#### onWithdraw()

**시그니처:**
```solidity
function onWithdraw(address user, uint amount, uint season)
    external onlyPool
```

**동작:**
- 랭킹 점수 감소

#### onSeasonEnd()

**시그니처:**
```solidity
function onSeasonEnd(uint season, uint totalStaked, uint totalPoints)
    external onlyPool
```

**동작:**
- 시즌 랭킹 확정
- SeasonRankingFinalized 이벤트

#### onClaim()

**시그니처:**
```solidity
function onClaim(address user, uint season, uint points, uint rewardAmount)
    external onlyPool
```

**동작:**
- 선택적 구현 (필요 시 청구 기록)

### 조회 함수들

#### getUserRankingScore()

**시그니처:**
```solidity
function getUserRankingScore(uint season, address user)
    external view returns (uint)
```

#### getTopStakers()

**시그니처:**
```solidity
function getTopStakers(uint season, uint offset, uint limit)
    external view
    returns (address[] memory stakers, uint[] memory scores)
```

**용도:**
- Top 스테이커 목록 페이지네이션 조회

#### getTotalParticipants()

**시그니처:**
```solidity
function getTotalParticipants(uint season)
    external view returns (uint)
```

---

## 다음 문서

- [04-워크플로우.md](./04-워크플로우.md): 실제 사용 시나리오
- [05-기술구현.md](./05-기술구현.md): 기술적 구현 디테일

